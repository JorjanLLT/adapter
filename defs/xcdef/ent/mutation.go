// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/auroraride/adapter"
	"github.com/auroraride/adapter/defs/batdef"
	"github.com/auroraride/adapter/defs/xcdef"
	"github.com/auroraride/adapter/defs/xcdef/ent/battery"
	"github.com/auroraride/adapter/defs/xcdef/ent/heartbeat"
	"github.com/auroraride/adapter/defs/xcdef/ent/predicate"
	"github.com/auroraride/adapter/defs/xcdef/ent/reign"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBattery   = "Battery"
	TypeHeartbeat = "Heartbeat"
	TypeReign     = "Reign"
)

// BatteryMutation represents an operation that mutates the Battery nodes in the graph.
type BatteryMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	created_at         *time.Time
	updated_at         *time.Time
	sn                 *string
	soft_version       *uint16
	addsoft_version    *int16
	hard_version       *uint16
	addhard_version    *int16
	soft_4g_version    *uint16
	addsoft_4g_version *int16
	hard_4g_version    *uint16
	addhard_4g_version *int16
	sn_4g              *uint64
	addsn_4g           *int64
	iccid              *string
	soc                *uint16
	addsoc             *int16
	clearedFields      map[string]struct{}
	heartbeats         map[int]struct{}
	removedheartbeats  map[int]struct{}
	clearedheartbeats  bool
	reigns             map[int]struct{}
	removedreigns      map[int]struct{}
	clearedreigns      bool
	done               bool
	oldValue           func(context.Context) (*Battery, error)
	predicates         []predicate.Battery
}

var _ ent.Mutation = (*BatteryMutation)(nil)

// batteryOption allows management of the mutation configuration using functional options.
type batteryOption func(*BatteryMutation)

// newBatteryMutation creates new mutation for the Battery entity.
func newBatteryMutation(c config, op Op, opts ...batteryOption) *BatteryMutation {
	m := &BatteryMutation{
		config:        c,
		op:            op,
		typ:           TypeBattery,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBatteryID sets the ID field of the mutation.
func withBatteryID(id int) batteryOption {
	return func(m *BatteryMutation) {
		var (
			err   error
			once  sync.Once
			value *Battery
		)
		m.oldValue = func(ctx context.Context) (*Battery, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Battery.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBattery sets the old Battery of the mutation.
func withBattery(node *Battery) batteryOption {
	return func(m *BatteryMutation) {
		m.oldValue = func(context.Context) (*Battery, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BatteryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BatteryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BatteryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BatteryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Battery.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BatteryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BatteryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Battery entity.
// If the Battery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BatteryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BatteryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BatteryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Battery entity.
// If the Battery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BatteryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetSn sets the "sn" field.
func (m *BatteryMutation) SetSn(s string) {
	m.sn = &s
}

// Sn returns the value of the "sn" field in the mutation.
func (m *BatteryMutation) Sn() (r string, exists bool) {
	v := m.sn
	if v == nil {
		return
	}
	return *v, true
}

// OldSn returns the old "sn" field's value of the Battery entity.
// If the Battery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryMutation) OldSn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSn: %w", err)
	}
	return oldValue.Sn, nil
}

// ResetSn resets all changes to the "sn" field.
func (m *BatteryMutation) ResetSn() {
	m.sn = nil
}

// SetSoftVersion sets the "soft_version" field.
func (m *BatteryMutation) SetSoftVersion(u uint16) {
	m.soft_version = &u
	m.addsoft_version = nil
}

// SoftVersion returns the value of the "soft_version" field in the mutation.
func (m *BatteryMutation) SoftVersion() (r uint16, exists bool) {
	v := m.soft_version
	if v == nil {
		return
	}
	return *v, true
}

// OldSoftVersion returns the old "soft_version" field's value of the Battery entity.
// If the Battery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryMutation) OldSoftVersion(ctx context.Context) (v *uint16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSoftVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSoftVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSoftVersion: %w", err)
	}
	return oldValue.SoftVersion, nil
}

// AddSoftVersion adds u to the "soft_version" field.
func (m *BatteryMutation) AddSoftVersion(u int16) {
	if m.addsoft_version != nil {
		*m.addsoft_version += u
	} else {
		m.addsoft_version = &u
	}
}

// AddedSoftVersion returns the value that was added to the "soft_version" field in this mutation.
func (m *BatteryMutation) AddedSoftVersion() (r int16, exists bool) {
	v := m.addsoft_version
	if v == nil {
		return
	}
	return *v, true
}

// ClearSoftVersion clears the value of the "soft_version" field.
func (m *BatteryMutation) ClearSoftVersion() {
	m.soft_version = nil
	m.addsoft_version = nil
	m.clearedFields[battery.FieldSoftVersion] = struct{}{}
}

// SoftVersionCleared returns if the "soft_version" field was cleared in this mutation.
func (m *BatteryMutation) SoftVersionCleared() bool {
	_, ok := m.clearedFields[battery.FieldSoftVersion]
	return ok
}

// ResetSoftVersion resets all changes to the "soft_version" field.
func (m *BatteryMutation) ResetSoftVersion() {
	m.soft_version = nil
	m.addsoft_version = nil
	delete(m.clearedFields, battery.FieldSoftVersion)
}

// SetHardVersion sets the "hard_version" field.
func (m *BatteryMutation) SetHardVersion(u uint16) {
	m.hard_version = &u
	m.addhard_version = nil
}

// HardVersion returns the value of the "hard_version" field in the mutation.
func (m *BatteryMutation) HardVersion() (r uint16, exists bool) {
	v := m.hard_version
	if v == nil {
		return
	}
	return *v, true
}

// OldHardVersion returns the old "hard_version" field's value of the Battery entity.
// If the Battery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryMutation) OldHardVersion(ctx context.Context) (v *uint16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHardVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHardVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHardVersion: %w", err)
	}
	return oldValue.HardVersion, nil
}

// AddHardVersion adds u to the "hard_version" field.
func (m *BatteryMutation) AddHardVersion(u int16) {
	if m.addhard_version != nil {
		*m.addhard_version += u
	} else {
		m.addhard_version = &u
	}
}

// AddedHardVersion returns the value that was added to the "hard_version" field in this mutation.
func (m *BatteryMutation) AddedHardVersion() (r int16, exists bool) {
	v := m.addhard_version
	if v == nil {
		return
	}
	return *v, true
}

// ClearHardVersion clears the value of the "hard_version" field.
func (m *BatteryMutation) ClearHardVersion() {
	m.hard_version = nil
	m.addhard_version = nil
	m.clearedFields[battery.FieldHardVersion] = struct{}{}
}

// HardVersionCleared returns if the "hard_version" field was cleared in this mutation.
func (m *BatteryMutation) HardVersionCleared() bool {
	_, ok := m.clearedFields[battery.FieldHardVersion]
	return ok
}

// ResetHardVersion resets all changes to the "hard_version" field.
func (m *BatteryMutation) ResetHardVersion() {
	m.hard_version = nil
	m.addhard_version = nil
	delete(m.clearedFields, battery.FieldHardVersion)
}

// SetSoft4gVersion sets the "soft_4g_version" field.
func (m *BatteryMutation) SetSoft4gVersion(u uint16) {
	m.soft_4g_version = &u
	m.addsoft_4g_version = nil
}

// Soft4gVersion returns the value of the "soft_4g_version" field in the mutation.
func (m *BatteryMutation) Soft4gVersion() (r uint16, exists bool) {
	v := m.soft_4g_version
	if v == nil {
		return
	}
	return *v, true
}

// OldSoft4gVersion returns the old "soft_4g_version" field's value of the Battery entity.
// If the Battery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryMutation) OldSoft4gVersion(ctx context.Context) (v *uint16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSoft4gVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSoft4gVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSoft4gVersion: %w", err)
	}
	return oldValue.Soft4gVersion, nil
}

// AddSoft4gVersion adds u to the "soft_4g_version" field.
func (m *BatteryMutation) AddSoft4gVersion(u int16) {
	if m.addsoft_4g_version != nil {
		*m.addsoft_4g_version += u
	} else {
		m.addsoft_4g_version = &u
	}
}

// AddedSoft4gVersion returns the value that was added to the "soft_4g_version" field in this mutation.
func (m *BatteryMutation) AddedSoft4gVersion() (r int16, exists bool) {
	v := m.addsoft_4g_version
	if v == nil {
		return
	}
	return *v, true
}

// ClearSoft4gVersion clears the value of the "soft_4g_version" field.
func (m *BatteryMutation) ClearSoft4gVersion() {
	m.soft_4g_version = nil
	m.addsoft_4g_version = nil
	m.clearedFields[battery.FieldSoft4gVersion] = struct{}{}
}

// Soft4gVersionCleared returns if the "soft_4g_version" field was cleared in this mutation.
func (m *BatteryMutation) Soft4gVersionCleared() bool {
	_, ok := m.clearedFields[battery.FieldSoft4gVersion]
	return ok
}

// ResetSoft4gVersion resets all changes to the "soft_4g_version" field.
func (m *BatteryMutation) ResetSoft4gVersion() {
	m.soft_4g_version = nil
	m.addsoft_4g_version = nil
	delete(m.clearedFields, battery.FieldSoft4gVersion)
}

// SetHard4gVersion sets the "hard_4g_version" field.
func (m *BatteryMutation) SetHard4gVersion(u uint16) {
	m.hard_4g_version = &u
	m.addhard_4g_version = nil
}

// Hard4gVersion returns the value of the "hard_4g_version" field in the mutation.
func (m *BatteryMutation) Hard4gVersion() (r uint16, exists bool) {
	v := m.hard_4g_version
	if v == nil {
		return
	}
	return *v, true
}

// OldHard4gVersion returns the old "hard_4g_version" field's value of the Battery entity.
// If the Battery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryMutation) OldHard4gVersion(ctx context.Context) (v *uint16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHard4gVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHard4gVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHard4gVersion: %w", err)
	}
	return oldValue.Hard4gVersion, nil
}

// AddHard4gVersion adds u to the "hard_4g_version" field.
func (m *BatteryMutation) AddHard4gVersion(u int16) {
	if m.addhard_4g_version != nil {
		*m.addhard_4g_version += u
	} else {
		m.addhard_4g_version = &u
	}
}

// AddedHard4gVersion returns the value that was added to the "hard_4g_version" field in this mutation.
func (m *BatteryMutation) AddedHard4gVersion() (r int16, exists bool) {
	v := m.addhard_4g_version
	if v == nil {
		return
	}
	return *v, true
}

// ClearHard4gVersion clears the value of the "hard_4g_version" field.
func (m *BatteryMutation) ClearHard4gVersion() {
	m.hard_4g_version = nil
	m.addhard_4g_version = nil
	m.clearedFields[battery.FieldHard4gVersion] = struct{}{}
}

// Hard4gVersionCleared returns if the "hard_4g_version" field was cleared in this mutation.
func (m *BatteryMutation) Hard4gVersionCleared() bool {
	_, ok := m.clearedFields[battery.FieldHard4gVersion]
	return ok
}

// ResetHard4gVersion resets all changes to the "hard_4g_version" field.
func (m *BatteryMutation) ResetHard4gVersion() {
	m.hard_4g_version = nil
	m.addhard_4g_version = nil
	delete(m.clearedFields, battery.FieldHard4gVersion)
}

// SetSn4g sets the "sn_4g" field.
func (m *BatteryMutation) SetSn4g(u uint64) {
	m.sn_4g = &u
	m.addsn_4g = nil
}

// Sn4g returns the value of the "sn_4g" field in the mutation.
func (m *BatteryMutation) Sn4g() (r uint64, exists bool) {
	v := m.sn_4g
	if v == nil {
		return
	}
	return *v, true
}

// OldSn4g returns the old "sn_4g" field's value of the Battery entity.
// If the Battery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryMutation) OldSn4g(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSn4g is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSn4g requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSn4g: %w", err)
	}
	return oldValue.Sn4g, nil
}

// AddSn4g adds u to the "sn_4g" field.
func (m *BatteryMutation) AddSn4g(u int64) {
	if m.addsn_4g != nil {
		*m.addsn_4g += u
	} else {
		m.addsn_4g = &u
	}
}

// AddedSn4g returns the value that was added to the "sn_4g" field in this mutation.
func (m *BatteryMutation) AddedSn4g() (r int64, exists bool) {
	v := m.addsn_4g
	if v == nil {
		return
	}
	return *v, true
}

// ClearSn4g clears the value of the "sn_4g" field.
func (m *BatteryMutation) ClearSn4g() {
	m.sn_4g = nil
	m.addsn_4g = nil
	m.clearedFields[battery.FieldSn4g] = struct{}{}
}

// Sn4gCleared returns if the "sn_4g" field was cleared in this mutation.
func (m *BatteryMutation) Sn4gCleared() bool {
	_, ok := m.clearedFields[battery.FieldSn4g]
	return ok
}

// ResetSn4g resets all changes to the "sn_4g" field.
func (m *BatteryMutation) ResetSn4g() {
	m.sn_4g = nil
	m.addsn_4g = nil
	delete(m.clearedFields, battery.FieldSn4g)
}

// SetIccid sets the "iccid" field.
func (m *BatteryMutation) SetIccid(s string) {
	m.iccid = &s
}

// Iccid returns the value of the "iccid" field in the mutation.
func (m *BatteryMutation) Iccid() (r string, exists bool) {
	v := m.iccid
	if v == nil {
		return
	}
	return *v, true
}

// OldIccid returns the old "iccid" field's value of the Battery entity.
// If the Battery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryMutation) OldIccid(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIccid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIccid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIccid: %w", err)
	}
	return oldValue.Iccid, nil
}

// ClearIccid clears the value of the "iccid" field.
func (m *BatteryMutation) ClearIccid() {
	m.iccid = nil
	m.clearedFields[battery.FieldIccid] = struct{}{}
}

// IccidCleared returns if the "iccid" field was cleared in this mutation.
func (m *BatteryMutation) IccidCleared() bool {
	_, ok := m.clearedFields[battery.FieldIccid]
	return ok
}

// ResetIccid resets all changes to the "iccid" field.
func (m *BatteryMutation) ResetIccid() {
	m.iccid = nil
	delete(m.clearedFields, battery.FieldIccid)
}

// SetSoc sets the "soc" field.
func (m *BatteryMutation) SetSoc(u uint16) {
	m.soc = &u
	m.addsoc = nil
}

// Soc returns the value of the "soc" field in the mutation.
func (m *BatteryMutation) Soc() (r uint16, exists bool) {
	v := m.soc
	if v == nil {
		return
	}
	return *v, true
}

// OldSoc returns the old "soc" field's value of the Battery entity.
// If the Battery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryMutation) OldSoc(ctx context.Context) (v *uint16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSoc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSoc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSoc: %w", err)
	}
	return oldValue.Soc, nil
}

// AddSoc adds u to the "soc" field.
func (m *BatteryMutation) AddSoc(u int16) {
	if m.addsoc != nil {
		*m.addsoc += u
	} else {
		m.addsoc = &u
	}
}

// AddedSoc returns the value that was added to the "soc" field in this mutation.
func (m *BatteryMutation) AddedSoc() (r int16, exists bool) {
	v := m.addsoc
	if v == nil {
		return
	}
	return *v, true
}

// ClearSoc clears the value of the "soc" field.
func (m *BatteryMutation) ClearSoc() {
	m.soc = nil
	m.addsoc = nil
	m.clearedFields[battery.FieldSoc] = struct{}{}
}

// SocCleared returns if the "soc" field was cleared in this mutation.
func (m *BatteryMutation) SocCleared() bool {
	_, ok := m.clearedFields[battery.FieldSoc]
	return ok
}

// ResetSoc resets all changes to the "soc" field.
func (m *BatteryMutation) ResetSoc() {
	m.soc = nil
	m.addsoc = nil
	delete(m.clearedFields, battery.FieldSoc)
}

// AddHeartbeatIDs adds the "heartbeats" edge to the Heartbeat entity by ids.
func (m *BatteryMutation) AddHeartbeatIDs(ids ...int) {
	if m.heartbeats == nil {
		m.heartbeats = make(map[int]struct{})
	}
	for i := range ids {
		m.heartbeats[ids[i]] = struct{}{}
	}
}

// ClearHeartbeats clears the "heartbeats" edge to the Heartbeat entity.
func (m *BatteryMutation) ClearHeartbeats() {
	m.clearedheartbeats = true
}

// HeartbeatsCleared reports if the "heartbeats" edge to the Heartbeat entity was cleared.
func (m *BatteryMutation) HeartbeatsCleared() bool {
	return m.clearedheartbeats
}

// RemoveHeartbeatIDs removes the "heartbeats" edge to the Heartbeat entity by IDs.
func (m *BatteryMutation) RemoveHeartbeatIDs(ids ...int) {
	if m.removedheartbeats == nil {
		m.removedheartbeats = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.heartbeats, ids[i])
		m.removedheartbeats[ids[i]] = struct{}{}
	}
}

// RemovedHeartbeats returns the removed IDs of the "heartbeats" edge to the Heartbeat entity.
func (m *BatteryMutation) RemovedHeartbeatsIDs() (ids []int) {
	for id := range m.removedheartbeats {
		ids = append(ids, id)
	}
	return
}

// HeartbeatsIDs returns the "heartbeats" edge IDs in the mutation.
func (m *BatteryMutation) HeartbeatsIDs() (ids []int) {
	for id := range m.heartbeats {
		ids = append(ids, id)
	}
	return
}

// ResetHeartbeats resets all changes to the "heartbeats" edge.
func (m *BatteryMutation) ResetHeartbeats() {
	m.heartbeats = nil
	m.clearedheartbeats = false
	m.removedheartbeats = nil
}

// AddReignIDs adds the "reigns" edge to the Reign entity by ids.
func (m *BatteryMutation) AddReignIDs(ids ...int) {
	if m.reigns == nil {
		m.reigns = make(map[int]struct{})
	}
	for i := range ids {
		m.reigns[ids[i]] = struct{}{}
	}
}

// ClearReigns clears the "reigns" edge to the Reign entity.
func (m *BatteryMutation) ClearReigns() {
	m.clearedreigns = true
}

// ReignsCleared reports if the "reigns" edge to the Reign entity was cleared.
func (m *BatteryMutation) ReignsCleared() bool {
	return m.clearedreigns
}

// RemoveReignIDs removes the "reigns" edge to the Reign entity by IDs.
func (m *BatteryMutation) RemoveReignIDs(ids ...int) {
	if m.removedreigns == nil {
		m.removedreigns = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.reigns, ids[i])
		m.removedreigns[ids[i]] = struct{}{}
	}
}

// RemovedReigns returns the removed IDs of the "reigns" edge to the Reign entity.
func (m *BatteryMutation) RemovedReignsIDs() (ids []int) {
	for id := range m.removedreigns {
		ids = append(ids, id)
	}
	return
}

// ReignsIDs returns the "reigns" edge IDs in the mutation.
func (m *BatteryMutation) ReignsIDs() (ids []int) {
	for id := range m.reigns {
		ids = append(ids, id)
	}
	return
}

// ResetReigns resets all changes to the "reigns" edge.
func (m *BatteryMutation) ResetReigns() {
	m.reigns = nil
	m.clearedreigns = false
	m.removedreigns = nil
}

// Where appends a list predicates to the BatteryMutation builder.
func (m *BatteryMutation) Where(ps ...predicate.Battery) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BatteryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BatteryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Battery, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BatteryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BatteryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Battery).
func (m *BatteryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BatteryMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, battery.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, battery.FieldUpdatedAt)
	}
	if m.sn != nil {
		fields = append(fields, battery.FieldSn)
	}
	if m.soft_version != nil {
		fields = append(fields, battery.FieldSoftVersion)
	}
	if m.hard_version != nil {
		fields = append(fields, battery.FieldHardVersion)
	}
	if m.soft_4g_version != nil {
		fields = append(fields, battery.FieldSoft4gVersion)
	}
	if m.hard_4g_version != nil {
		fields = append(fields, battery.FieldHard4gVersion)
	}
	if m.sn_4g != nil {
		fields = append(fields, battery.FieldSn4g)
	}
	if m.iccid != nil {
		fields = append(fields, battery.FieldIccid)
	}
	if m.soc != nil {
		fields = append(fields, battery.FieldSoc)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BatteryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case battery.FieldCreatedAt:
		return m.CreatedAt()
	case battery.FieldUpdatedAt:
		return m.UpdatedAt()
	case battery.FieldSn:
		return m.Sn()
	case battery.FieldSoftVersion:
		return m.SoftVersion()
	case battery.FieldHardVersion:
		return m.HardVersion()
	case battery.FieldSoft4gVersion:
		return m.Soft4gVersion()
	case battery.FieldHard4gVersion:
		return m.Hard4gVersion()
	case battery.FieldSn4g:
		return m.Sn4g()
	case battery.FieldIccid:
		return m.Iccid()
	case battery.FieldSoc:
		return m.Soc()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BatteryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case battery.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case battery.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case battery.FieldSn:
		return m.OldSn(ctx)
	case battery.FieldSoftVersion:
		return m.OldSoftVersion(ctx)
	case battery.FieldHardVersion:
		return m.OldHardVersion(ctx)
	case battery.FieldSoft4gVersion:
		return m.OldSoft4gVersion(ctx)
	case battery.FieldHard4gVersion:
		return m.OldHard4gVersion(ctx)
	case battery.FieldSn4g:
		return m.OldSn4g(ctx)
	case battery.FieldIccid:
		return m.OldIccid(ctx)
	case battery.FieldSoc:
		return m.OldSoc(ctx)
	}
	return nil, fmt.Errorf("unknown Battery field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BatteryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case battery.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case battery.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case battery.FieldSn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSn(v)
		return nil
	case battery.FieldSoftVersion:
		v, ok := value.(uint16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSoftVersion(v)
		return nil
	case battery.FieldHardVersion:
		v, ok := value.(uint16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHardVersion(v)
		return nil
	case battery.FieldSoft4gVersion:
		v, ok := value.(uint16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSoft4gVersion(v)
		return nil
	case battery.FieldHard4gVersion:
		v, ok := value.(uint16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHard4gVersion(v)
		return nil
	case battery.FieldSn4g:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSn4g(v)
		return nil
	case battery.FieldIccid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIccid(v)
		return nil
	case battery.FieldSoc:
		v, ok := value.(uint16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSoc(v)
		return nil
	}
	return fmt.Errorf("unknown Battery field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BatteryMutation) AddedFields() []string {
	var fields []string
	if m.addsoft_version != nil {
		fields = append(fields, battery.FieldSoftVersion)
	}
	if m.addhard_version != nil {
		fields = append(fields, battery.FieldHardVersion)
	}
	if m.addsoft_4g_version != nil {
		fields = append(fields, battery.FieldSoft4gVersion)
	}
	if m.addhard_4g_version != nil {
		fields = append(fields, battery.FieldHard4gVersion)
	}
	if m.addsn_4g != nil {
		fields = append(fields, battery.FieldSn4g)
	}
	if m.addsoc != nil {
		fields = append(fields, battery.FieldSoc)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BatteryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case battery.FieldSoftVersion:
		return m.AddedSoftVersion()
	case battery.FieldHardVersion:
		return m.AddedHardVersion()
	case battery.FieldSoft4gVersion:
		return m.AddedSoft4gVersion()
	case battery.FieldHard4gVersion:
		return m.AddedHard4gVersion()
	case battery.FieldSn4g:
		return m.AddedSn4g()
	case battery.FieldSoc:
		return m.AddedSoc()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BatteryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case battery.FieldSoftVersion:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSoftVersion(v)
		return nil
	case battery.FieldHardVersion:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHardVersion(v)
		return nil
	case battery.FieldSoft4gVersion:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSoft4gVersion(v)
		return nil
	case battery.FieldHard4gVersion:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHard4gVersion(v)
		return nil
	case battery.FieldSn4g:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSn4g(v)
		return nil
	case battery.FieldSoc:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSoc(v)
		return nil
	}
	return fmt.Errorf("unknown Battery numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BatteryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(battery.FieldSoftVersion) {
		fields = append(fields, battery.FieldSoftVersion)
	}
	if m.FieldCleared(battery.FieldHardVersion) {
		fields = append(fields, battery.FieldHardVersion)
	}
	if m.FieldCleared(battery.FieldSoft4gVersion) {
		fields = append(fields, battery.FieldSoft4gVersion)
	}
	if m.FieldCleared(battery.FieldHard4gVersion) {
		fields = append(fields, battery.FieldHard4gVersion)
	}
	if m.FieldCleared(battery.FieldSn4g) {
		fields = append(fields, battery.FieldSn4g)
	}
	if m.FieldCleared(battery.FieldIccid) {
		fields = append(fields, battery.FieldIccid)
	}
	if m.FieldCleared(battery.FieldSoc) {
		fields = append(fields, battery.FieldSoc)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BatteryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BatteryMutation) ClearField(name string) error {
	switch name {
	case battery.FieldSoftVersion:
		m.ClearSoftVersion()
		return nil
	case battery.FieldHardVersion:
		m.ClearHardVersion()
		return nil
	case battery.FieldSoft4gVersion:
		m.ClearSoft4gVersion()
		return nil
	case battery.FieldHard4gVersion:
		m.ClearHard4gVersion()
		return nil
	case battery.FieldSn4g:
		m.ClearSn4g()
		return nil
	case battery.FieldIccid:
		m.ClearIccid()
		return nil
	case battery.FieldSoc:
		m.ClearSoc()
		return nil
	}
	return fmt.Errorf("unknown Battery nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BatteryMutation) ResetField(name string) error {
	switch name {
	case battery.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case battery.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case battery.FieldSn:
		m.ResetSn()
		return nil
	case battery.FieldSoftVersion:
		m.ResetSoftVersion()
		return nil
	case battery.FieldHardVersion:
		m.ResetHardVersion()
		return nil
	case battery.FieldSoft4gVersion:
		m.ResetSoft4gVersion()
		return nil
	case battery.FieldHard4gVersion:
		m.ResetHard4gVersion()
		return nil
	case battery.FieldSn4g:
		m.ResetSn4g()
		return nil
	case battery.FieldIccid:
		m.ResetIccid()
		return nil
	case battery.FieldSoc:
		m.ResetSoc()
		return nil
	}
	return fmt.Errorf("unknown Battery field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BatteryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.heartbeats != nil {
		edges = append(edges, battery.EdgeHeartbeats)
	}
	if m.reigns != nil {
		edges = append(edges, battery.EdgeReigns)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BatteryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case battery.EdgeHeartbeats:
		ids := make([]ent.Value, 0, len(m.heartbeats))
		for id := range m.heartbeats {
			ids = append(ids, id)
		}
		return ids
	case battery.EdgeReigns:
		ids := make([]ent.Value, 0, len(m.reigns))
		for id := range m.reigns {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BatteryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedheartbeats != nil {
		edges = append(edges, battery.EdgeHeartbeats)
	}
	if m.removedreigns != nil {
		edges = append(edges, battery.EdgeReigns)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BatteryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case battery.EdgeHeartbeats:
		ids := make([]ent.Value, 0, len(m.removedheartbeats))
		for id := range m.removedheartbeats {
			ids = append(ids, id)
		}
		return ids
	case battery.EdgeReigns:
		ids := make([]ent.Value, 0, len(m.removedreigns))
		for id := range m.removedreigns {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BatteryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedheartbeats {
		edges = append(edges, battery.EdgeHeartbeats)
	}
	if m.clearedreigns {
		edges = append(edges, battery.EdgeReigns)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BatteryMutation) EdgeCleared(name string) bool {
	switch name {
	case battery.EdgeHeartbeats:
		return m.clearedheartbeats
	case battery.EdgeReigns:
		return m.clearedreigns
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BatteryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Battery unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BatteryMutation) ResetEdge(name string) error {
	switch name {
	case battery.EdgeHeartbeats:
		m.ResetHeartbeats()
		return nil
	case battery.EdgeReigns:
		m.ResetReigns()
		return nil
	}
	return fmt.Errorf("unknown Battery edge %s", name)
}

// HeartbeatMutation represents an operation that mutates the Heartbeat nodes in the graph.
type HeartbeatMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	sn                         *string
	created_at                 *time.Time
	voltage                    *float64
	addvoltage                 *float64
	current                    *float64
	addcurrent                 *float64
	soc                        *uint8
	addsoc                     *int8
	soh                        *uint8
	addsoh                     *int8
	in_cabinet                 *bool
	capacity                   *float64
	addcapacity                *float64
	mon_max_voltage            *uint16
	addmon_max_voltage         *int16
	mon_max_voltage_pos        *uint8
	addmon_max_voltage_pos     *int8
	mon_min_voltage            *uint16
	addmon_min_voltage         *int16
	mon_min_voltage_pos        *uint8
	addmon_min_voltage_pos     *int8
	max_temp                   *uint16
	addmax_temp                *int16
	min_temp                   *uint16
	addmin_temp                *int16
	faults                     **xcdef.Faults
	mos_status                 **xcdef.MosStatus
	mon_voltage                **xcdef.MonVoltage
	temp                       **xcdef.Temperature
	mos_temp                   *uint16
	addmos_temp                *int16
	env_temp                   *uint16
	addenv_temp                *int16
	geom                       **adapter.Geometry
	gps                        *xcdef.GPSStatus
	strength                   *uint8
	addstrength                *int8
	cycles                     *uint16
	addcycles                  *int16
	charging_time              *uint32
	addcharging_time           *int32
	dis_charging_time          *uint32
	adddis_charging_time       *int32
	using_time                 *uint32
	addusing_time              *int32
	total_charging_time        *uint32
	addtotal_charging_time     *int32
	total_dis_charging_time    *uint32
	addtotal_dis_charging_time *int32
	total_using_time           *uint32
	addtotal_using_time        *int32
	clearedFields              map[string]struct{}
	battery                    *int
	clearedbattery             bool
	done                       bool
	oldValue                   func(context.Context) (*Heartbeat, error)
	predicates                 []predicate.Heartbeat
}

var _ ent.Mutation = (*HeartbeatMutation)(nil)

// heartbeatOption allows management of the mutation configuration using functional options.
type heartbeatOption func(*HeartbeatMutation)

// newHeartbeatMutation creates new mutation for the Heartbeat entity.
func newHeartbeatMutation(c config, op Op, opts ...heartbeatOption) *HeartbeatMutation {
	m := &HeartbeatMutation{
		config:        c,
		op:            op,
		typ:           TypeHeartbeat,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHeartbeatID sets the ID field of the mutation.
func withHeartbeatID(id int) heartbeatOption {
	return func(m *HeartbeatMutation) {
		var (
			err   error
			once  sync.Once
			value *Heartbeat
		)
		m.oldValue = func(ctx context.Context) (*Heartbeat, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Heartbeat.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHeartbeat sets the old Heartbeat of the mutation.
func withHeartbeat(node *Heartbeat) heartbeatOption {
	return func(m *HeartbeatMutation) {
		m.oldValue = func(context.Context) (*Heartbeat, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HeartbeatMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HeartbeatMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HeartbeatMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HeartbeatMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Heartbeat.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSn sets the "sn" field.
func (m *HeartbeatMutation) SetSn(s string) {
	m.sn = &s
}

// Sn returns the value of the "sn" field in the mutation.
func (m *HeartbeatMutation) Sn() (r string, exists bool) {
	v := m.sn
	if v == nil {
		return
	}
	return *v, true
}

// OldSn returns the old "sn" field's value of the Heartbeat entity.
// If the Heartbeat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HeartbeatMutation) OldSn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSn: %w", err)
	}
	return oldValue.Sn, nil
}

// ResetSn resets all changes to the "sn" field.
func (m *HeartbeatMutation) ResetSn() {
	m.sn = nil
}

// SetBatteryID sets the "battery_id" field.
func (m *HeartbeatMutation) SetBatteryID(i int) {
	m.battery = &i
}

// BatteryID returns the value of the "battery_id" field in the mutation.
func (m *HeartbeatMutation) BatteryID() (r int, exists bool) {
	v := m.battery
	if v == nil {
		return
	}
	return *v, true
}

// OldBatteryID returns the old "battery_id" field's value of the Heartbeat entity.
// If the Heartbeat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HeartbeatMutation) OldBatteryID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBatteryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBatteryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBatteryID: %w", err)
	}
	return oldValue.BatteryID, nil
}

// ResetBatteryID resets all changes to the "battery_id" field.
func (m *HeartbeatMutation) ResetBatteryID() {
	m.battery = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *HeartbeatMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HeartbeatMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Heartbeat entity.
// If the Heartbeat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HeartbeatMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HeartbeatMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetVoltage sets the "voltage" field.
func (m *HeartbeatMutation) SetVoltage(f float64) {
	m.voltage = &f
	m.addvoltage = nil
}

// Voltage returns the value of the "voltage" field in the mutation.
func (m *HeartbeatMutation) Voltage() (r float64, exists bool) {
	v := m.voltage
	if v == nil {
		return
	}
	return *v, true
}

// OldVoltage returns the old "voltage" field's value of the Heartbeat entity.
// If the Heartbeat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HeartbeatMutation) OldVoltage(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVoltage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVoltage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVoltage: %w", err)
	}
	return oldValue.Voltage, nil
}

// AddVoltage adds f to the "voltage" field.
func (m *HeartbeatMutation) AddVoltage(f float64) {
	if m.addvoltage != nil {
		*m.addvoltage += f
	} else {
		m.addvoltage = &f
	}
}

// AddedVoltage returns the value that was added to the "voltage" field in this mutation.
func (m *HeartbeatMutation) AddedVoltage() (r float64, exists bool) {
	v := m.addvoltage
	if v == nil {
		return
	}
	return *v, true
}

// ResetVoltage resets all changes to the "voltage" field.
func (m *HeartbeatMutation) ResetVoltage() {
	m.voltage = nil
	m.addvoltage = nil
}

// SetCurrent sets the "current" field.
func (m *HeartbeatMutation) SetCurrent(f float64) {
	m.current = &f
	m.addcurrent = nil
}

// Current returns the value of the "current" field in the mutation.
func (m *HeartbeatMutation) Current() (r float64, exists bool) {
	v := m.current
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrent returns the old "current" field's value of the Heartbeat entity.
// If the Heartbeat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HeartbeatMutation) OldCurrent(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrent: %w", err)
	}
	return oldValue.Current, nil
}

// AddCurrent adds f to the "current" field.
func (m *HeartbeatMutation) AddCurrent(f float64) {
	if m.addcurrent != nil {
		*m.addcurrent += f
	} else {
		m.addcurrent = &f
	}
}

// AddedCurrent returns the value that was added to the "current" field in this mutation.
func (m *HeartbeatMutation) AddedCurrent() (r float64, exists bool) {
	v := m.addcurrent
	if v == nil {
		return
	}
	return *v, true
}

// ResetCurrent resets all changes to the "current" field.
func (m *HeartbeatMutation) ResetCurrent() {
	m.current = nil
	m.addcurrent = nil
}

// SetSoc sets the "soc" field.
func (m *HeartbeatMutation) SetSoc(u uint8) {
	m.soc = &u
	m.addsoc = nil
}

// Soc returns the value of the "soc" field in the mutation.
func (m *HeartbeatMutation) Soc() (r uint8, exists bool) {
	v := m.soc
	if v == nil {
		return
	}
	return *v, true
}

// OldSoc returns the old "soc" field's value of the Heartbeat entity.
// If the Heartbeat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HeartbeatMutation) OldSoc(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSoc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSoc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSoc: %w", err)
	}
	return oldValue.Soc, nil
}

// AddSoc adds u to the "soc" field.
func (m *HeartbeatMutation) AddSoc(u int8) {
	if m.addsoc != nil {
		*m.addsoc += u
	} else {
		m.addsoc = &u
	}
}

// AddedSoc returns the value that was added to the "soc" field in this mutation.
func (m *HeartbeatMutation) AddedSoc() (r int8, exists bool) {
	v := m.addsoc
	if v == nil {
		return
	}
	return *v, true
}

// ResetSoc resets all changes to the "soc" field.
func (m *HeartbeatMutation) ResetSoc() {
	m.soc = nil
	m.addsoc = nil
}

// SetSoh sets the "soh" field.
func (m *HeartbeatMutation) SetSoh(u uint8) {
	m.soh = &u
	m.addsoh = nil
}

// Soh returns the value of the "soh" field in the mutation.
func (m *HeartbeatMutation) Soh() (r uint8, exists bool) {
	v := m.soh
	if v == nil {
		return
	}
	return *v, true
}

// OldSoh returns the old "soh" field's value of the Heartbeat entity.
// If the Heartbeat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HeartbeatMutation) OldSoh(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSoh is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSoh requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSoh: %w", err)
	}
	return oldValue.Soh, nil
}

// AddSoh adds u to the "soh" field.
func (m *HeartbeatMutation) AddSoh(u int8) {
	if m.addsoh != nil {
		*m.addsoh += u
	} else {
		m.addsoh = &u
	}
}

// AddedSoh returns the value that was added to the "soh" field in this mutation.
func (m *HeartbeatMutation) AddedSoh() (r int8, exists bool) {
	v := m.addsoh
	if v == nil {
		return
	}
	return *v, true
}

// ResetSoh resets all changes to the "soh" field.
func (m *HeartbeatMutation) ResetSoh() {
	m.soh = nil
	m.addsoh = nil
}

// SetInCabinet sets the "in_cabinet" field.
func (m *HeartbeatMutation) SetInCabinet(b bool) {
	m.in_cabinet = &b
}

// InCabinet returns the value of the "in_cabinet" field in the mutation.
func (m *HeartbeatMutation) InCabinet() (r bool, exists bool) {
	v := m.in_cabinet
	if v == nil {
		return
	}
	return *v, true
}

// OldInCabinet returns the old "in_cabinet" field's value of the Heartbeat entity.
// If the Heartbeat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HeartbeatMutation) OldInCabinet(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInCabinet is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInCabinet requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInCabinet: %w", err)
	}
	return oldValue.InCabinet, nil
}

// ResetInCabinet resets all changes to the "in_cabinet" field.
func (m *HeartbeatMutation) ResetInCabinet() {
	m.in_cabinet = nil
}

// SetCapacity sets the "capacity" field.
func (m *HeartbeatMutation) SetCapacity(f float64) {
	m.capacity = &f
	m.addcapacity = nil
}

// Capacity returns the value of the "capacity" field in the mutation.
func (m *HeartbeatMutation) Capacity() (r float64, exists bool) {
	v := m.capacity
	if v == nil {
		return
	}
	return *v, true
}

// OldCapacity returns the old "capacity" field's value of the Heartbeat entity.
// If the Heartbeat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HeartbeatMutation) OldCapacity(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCapacity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCapacity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCapacity: %w", err)
	}
	return oldValue.Capacity, nil
}

// AddCapacity adds f to the "capacity" field.
func (m *HeartbeatMutation) AddCapacity(f float64) {
	if m.addcapacity != nil {
		*m.addcapacity += f
	} else {
		m.addcapacity = &f
	}
}

// AddedCapacity returns the value that was added to the "capacity" field in this mutation.
func (m *HeartbeatMutation) AddedCapacity() (r float64, exists bool) {
	v := m.addcapacity
	if v == nil {
		return
	}
	return *v, true
}

// ResetCapacity resets all changes to the "capacity" field.
func (m *HeartbeatMutation) ResetCapacity() {
	m.capacity = nil
	m.addcapacity = nil
}

// SetMonMaxVoltage sets the "mon_max_voltage" field.
func (m *HeartbeatMutation) SetMonMaxVoltage(u uint16) {
	m.mon_max_voltage = &u
	m.addmon_max_voltage = nil
}

// MonMaxVoltage returns the value of the "mon_max_voltage" field in the mutation.
func (m *HeartbeatMutation) MonMaxVoltage() (r uint16, exists bool) {
	v := m.mon_max_voltage
	if v == nil {
		return
	}
	return *v, true
}

// OldMonMaxVoltage returns the old "mon_max_voltage" field's value of the Heartbeat entity.
// If the Heartbeat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HeartbeatMutation) OldMonMaxVoltage(ctx context.Context) (v uint16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMonMaxVoltage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMonMaxVoltage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMonMaxVoltage: %w", err)
	}
	return oldValue.MonMaxVoltage, nil
}

// AddMonMaxVoltage adds u to the "mon_max_voltage" field.
func (m *HeartbeatMutation) AddMonMaxVoltage(u int16) {
	if m.addmon_max_voltage != nil {
		*m.addmon_max_voltage += u
	} else {
		m.addmon_max_voltage = &u
	}
}

// AddedMonMaxVoltage returns the value that was added to the "mon_max_voltage" field in this mutation.
func (m *HeartbeatMutation) AddedMonMaxVoltage() (r int16, exists bool) {
	v := m.addmon_max_voltage
	if v == nil {
		return
	}
	return *v, true
}

// ResetMonMaxVoltage resets all changes to the "mon_max_voltage" field.
func (m *HeartbeatMutation) ResetMonMaxVoltage() {
	m.mon_max_voltage = nil
	m.addmon_max_voltage = nil
}

// SetMonMaxVoltagePos sets the "mon_max_voltage_pos" field.
func (m *HeartbeatMutation) SetMonMaxVoltagePos(u uint8) {
	m.mon_max_voltage_pos = &u
	m.addmon_max_voltage_pos = nil
}

// MonMaxVoltagePos returns the value of the "mon_max_voltage_pos" field in the mutation.
func (m *HeartbeatMutation) MonMaxVoltagePos() (r uint8, exists bool) {
	v := m.mon_max_voltage_pos
	if v == nil {
		return
	}
	return *v, true
}

// OldMonMaxVoltagePos returns the old "mon_max_voltage_pos" field's value of the Heartbeat entity.
// If the Heartbeat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HeartbeatMutation) OldMonMaxVoltagePos(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMonMaxVoltagePos is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMonMaxVoltagePos requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMonMaxVoltagePos: %w", err)
	}
	return oldValue.MonMaxVoltagePos, nil
}

// AddMonMaxVoltagePos adds u to the "mon_max_voltage_pos" field.
func (m *HeartbeatMutation) AddMonMaxVoltagePos(u int8) {
	if m.addmon_max_voltage_pos != nil {
		*m.addmon_max_voltage_pos += u
	} else {
		m.addmon_max_voltage_pos = &u
	}
}

// AddedMonMaxVoltagePos returns the value that was added to the "mon_max_voltage_pos" field in this mutation.
func (m *HeartbeatMutation) AddedMonMaxVoltagePos() (r int8, exists bool) {
	v := m.addmon_max_voltage_pos
	if v == nil {
		return
	}
	return *v, true
}

// ResetMonMaxVoltagePos resets all changes to the "mon_max_voltage_pos" field.
func (m *HeartbeatMutation) ResetMonMaxVoltagePos() {
	m.mon_max_voltage_pos = nil
	m.addmon_max_voltage_pos = nil
}

// SetMonMinVoltage sets the "mon_min_voltage" field.
func (m *HeartbeatMutation) SetMonMinVoltage(u uint16) {
	m.mon_min_voltage = &u
	m.addmon_min_voltage = nil
}

// MonMinVoltage returns the value of the "mon_min_voltage" field in the mutation.
func (m *HeartbeatMutation) MonMinVoltage() (r uint16, exists bool) {
	v := m.mon_min_voltage
	if v == nil {
		return
	}
	return *v, true
}

// OldMonMinVoltage returns the old "mon_min_voltage" field's value of the Heartbeat entity.
// If the Heartbeat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HeartbeatMutation) OldMonMinVoltage(ctx context.Context) (v uint16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMonMinVoltage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMonMinVoltage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMonMinVoltage: %w", err)
	}
	return oldValue.MonMinVoltage, nil
}

// AddMonMinVoltage adds u to the "mon_min_voltage" field.
func (m *HeartbeatMutation) AddMonMinVoltage(u int16) {
	if m.addmon_min_voltage != nil {
		*m.addmon_min_voltage += u
	} else {
		m.addmon_min_voltage = &u
	}
}

// AddedMonMinVoltage returns the value that was added to the "mon_min_voltage" field in this mutation.
func (m *HeartbeatMutation) AddedMonMinVoltage() (r int16, exists bool) {
	v := m.addmon_min_voltage
	if v == nil {
		return
	}
	return *v, true
}

// ResetMonMinVoltage resets all changes to the "mon_min_voltage" field.
func (m *HeartbeatMutation) ResetMonMinVoltage() {
	m.mon_min_voltage = nil
	m.addmon_min_voltage = nil
}

// SetMonMinVoltagePos sets the "mon_min_voltage_pos" field.
func (m *HeartbeatMutation) SetMonMinVoltagePos(u uint8) {
	m.mon_min_voltage_pos = &u
	m.addmon_min_voltage_pos = nil
}

// MonMinVoltagePos returns the value of the "mon_min_voltage_pos" field in the mutation.
func (m *HeartbeatMutation) MonMinVoltagePos() (r uint8, exists bool) {
	v := m.mon_min_voltage_pos
	if v == nil {
		return
	}
	return *v, true
}

// OldMonMinVoltagePos returns the old "mon_min_voltage_pos" field's value of the Heartbeat entity.
// If the Heartbeat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HeartbeatMutation) OldMonMinVoltagePos(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMonMinVoltagePos is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMonMinVoltagePos requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMonMinVoltagePos: %w", err)
	}
	return oldValue.MonMinVoltagePos, nil
}

// AddMonMinVoltagePos adds u to the "mon_min_voltage_pos" field.
func (m *HeartbeatMutation) AddMonMinVoltagePos(u int8) {
	if m.addmon_min_voltage_pos != nil {
		*m.addmon_min_voltage_pos += u
	} else {
		m.addmon_min_voltage_pos = &u
	}
}

// AddedMonMinVoltagePos returns the value that was added to the "mon_min_voltage_pos" field in this mutation.
func (m *HeartbeatMutation) AddedMonMinVoltagePos() (r int8, exists bool) {
	v := m.addmon_min_voltage_pos
	if v == nil {
		return
	}
	return *v, true
}

// ResetMonMinVoltagePos resets all changes to the "mon_min_voltage_pos" field.
func (m *HeartbeatMutation) ResetMonMinVoltagePos() {
	m.mon_min_voltage_pos = nil
	m.addmon_min_voltage_pos = nil
}

// SetMaxTemp sets the "max_temp" field.
func (m *HeartbeatMutation) SetMaxTemp(u uint16) {
	m.max_temp = &u
	m.addmax_temp = nil
}

// MaxTemp returns the value of the "max_temp" field in the mutation.
func (m *HeartbeatMutation) MaxTemp() (r uint16, exists bool) {
	v := m.max_temp
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxTemp returns the old "max_temp" field's value of the Heartbeat entity.
// If the Heartbeat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HeartbeatMutation) OldMaxTemp(ctx context.Context) (v uint16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxTemp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxTemp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxTemp: %w", err)
	}
	return oldValue.MaxTemp, nil
}

// AddMaxTemp adds u to the "max_temp" field.
func (m *HeartbeatMutation) AddMaxTemp(u int16) {
	if m.addmax_temp != nil {
		*m.addmax_temp += u
	} else {
		m.addmax_temp = &u
	}
}

// AddedMaxTemp returns the value that was added to the "max_temp" field in this mutation.
func (m *HeartbeatMutation) AddedMaxTemp() (r int16, exists bool) {
	v := m.addmax_temp
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxTemp resets all changes to the "max_temp" field.
func (m *HeartbeatMutation) ResetMaxTemp() {
	m.max_temp = nil
	m.addmax_temp = nil
}

// SetMinTemp sets the "min_temp" field.
func (m *HeartbeatMutation) SetMinTemp(u uint16) {
	m.min_temp = &u
	m.addmin_temp = nil
}

// MinTemp returns the value of the "min_temp" field in the mutation.
func (m *HeartbeatMutation) MinTemp() (r uint16, exists bool) {
	v := m.min_temp
	if v == nil {
		return
	}
	return *v, true
}

// OldMinTemp returns the old "min_temp" field's value of the Heartbeat entity.
// If the Heartbeat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HeartbeatMutation) OldMinTemp(ctx context.Context) (v uint16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinTemp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinTemp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinTemp: %w", err)
	}
	return oldValue.MinTemp, nil
}

// AddMinTemp adds u to the "min_temp" field.
func (m *HeartbeatMutation) AddMinTemp(u int16) {
	if m.addmin_temp != nil {
		*m.addmin_temp += u
	} else {
		m.addmin_temp = &u
	}
}

// AddedMinTemp returns the value that was added to the "min_temp" field in this mutation.
func (m *HeartbeatMutation) AddedMinTemp() (r int16, exists bool) {
	v := m.addmin_temp
	if v == nil {
		return
	}
	return *v, true
}

// ResetMinTemp resets all changes to the "min_temp" field.
func (m *HeartbeatMutation) ResetMinTemp() {
	m.min_temp = nil
	m.addmin_temp = nil
}

// SetFaults sets the "faults" field.
func (m *HeartbeatMutation) SetFaults(x *xcdef.Faults) {
	m.faults = &x
}

// Faults returns the value of the "faults" field in the mutation.
func (m *HeartbeatMutation) Faults() (r *xcdef.Faults, exists bool) {
	v := m.faults
	if v == nil {
		return
	}
	return *v, true
}

// OldFaults returns the old "faults" field's value of the Heartbeat entity.
// If the Heartbeat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HeartbeatMutation) OldFaults(ctx context.Context) (v *xcdef.Faults, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFaults is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFaults requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFaults: %w", err)
	}
	return oldValue.Faults, nil
}

// ClearFaults clears the value of the "faults" field.
func (m *HeartbeatMutation) ClearFaults() {
	m.faults = nil
	m.clearedFields[heartbeat.FieldFaults] = struct{}{}
}

// FaultsCleared returns if the "faults" field was cleared in this mutation.
func (m *HeartbeatMutation) FaultsCleared() bool {
	_, ok := m.clearedFields[heartbeat.FieldFaults]
	return ok
}

// ResetFaults resets all changes to the "faults" field.
func (m *HeartbeatMutation) ResetFaults() {
	m.faults = nil
	delete(m.clearedFields, heartbeat.FieldFaults)
}

// SetMosStatus sets the "mos_status" field.
func (m *HeartbeatMutation) SetMosStatus(xs *xcdef.MosStatus) {
	m.mos_status = &xs
}

// MosStatus returns the value of the "mos_status" field in the mutation.
func (m *HeartbeatMutation) MosStatus() (r *xcdef.MosStatus, exists bool) {
	v := m.mos_status
	if v == nil {
		return
	}
	return *v, true
}

// OldMosStatus returns the old "mos_status" field's value of the Heartbeat entity.
// If the Heartbeat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HeartbeatMutation) OldMosStatus(ctx context.Context) (v *xcdef.MosStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMosStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMosStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMosStatus: %w", err)
	}
	return oldValue.MosStatus, nil
}

// ResetMosStatus resets all changes to the "mos_status" field.
func (m *HeartbeatMutation) ResetMosStatus() {
	m.mos_status = nil
}

// SetMonVoltage sets the "mon_voltage" field.
func (m *HeartbeatMutation) SetMonVoltage(xv *xcdef.MonVoltage) {
	m.mon_voltage = &xv
}

// MonVoltage returns the value of the "mon_voltage" field in the mutation.
func (m *HeartbeatMutation) MonVoltage() (r *xcdef.MonVoltage, exists bool) {
	v := m.mon_voltage
	if v == nil {
		return
	}
	return *v, true
}

// OldMonVoltage returns the old "mon_voltage" field's value of the Heartbeat entity.
// If the Heartbeat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HeartbeatMutation) OldMonVoltage(ctx context.Context) (v *xcdef.MonVoltage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMonVoltage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMonVoltage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMonVoltage: %w", err)
	}
	return oldValue.MonVoltage, nil
}

// ResetMonVoltage resets all changes to the "mon_voltage" field.
func (m *HeartbeatMutation) ResetMonVoltage() {
	m.mon_voltage = nil
}

// SetTemp sets the "temp" field.
func (m *HeartbeatMutation) SetTemp(x *xcdef.Temperature) {
	m.temp = &x
}

// Temp returns the value of the "temp" field in the mutation.
func (m *HeartbeatMutation) Temp() (r *xcdef.Temperature, exists bool) {
	v := m.temp
	if v == nil {
		return
	}
	return *v, true
}

// OldTemp returns the old "temp" field's value of the Heartbeat entity.
// If the Heartbeat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HeartbeatMutation) OldTemp(ctx context.Context) (v *xcdef.Temperature, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemp: %w", err)
	}
	return oldValue.Temp, nil
}

// ResetTemp resets all changes to the "temp" field.
func (m *HeartbeatMutation) ResetTemp() {
	m.temp = nil
}

// SetMosTemp sets the "mos_temp" field.
func (m *HeartbeatMutation) SetMosTemp(u uint16) {
	m.mos_temp = &u
	m.addmos_temp = nil
}

// MosTemp returns the value of the "mos_temp" field in the mutation.
func (m *HeartbeatMutation) MosTemp() (r uint16, exists bool) {
	v := m.mos_temp
	if v == nil {
		return
	}
	return *v, true
}

// OldMosTemp returns the old "mos_temp" field's value of the Heartbeat entity.
// If the Heartbeat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HeartbeatMutation) OldMosTemp(ctx context.Context) (v uint16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMosTemp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMosTemp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMosTemp: %w", err)
	}
	return oldValue.MosTemp, nil
}

// AddMosTemp adds u to the "mos_temp" field.
func (m *HeartbeatMutation) AddMosTemp(u int16) {
	if m.addmos_temp != nil {
		*m.addmos_temp += u
	} else {
		m.addmos_temp = &u
	}
}

// AddedMosTemp returns the value that was added to the "mos_temp" field in this mutation.
func (m *HeartbeatMutation) AddedMosTemp() (r int16, exists bool) {
	v := m.addmos_temp
	if v == nil {
		return
	}
	return *v, true
}

// ResetMosTemp resets all changes to the "mos_temp" field.
func (m *HeartbeatMutation) ResetMosTemp() {
	m.mos_temp = nil
	m.addmos_temp = nil
}

// SetEnvTemp sets the "env_temp" field.
func (m *HeartbeatMutation) SetEnvTemp(u uint16) {
	m.env_temp = &u
	m.addenv_temp = nil
}

// EnvTemp returns the value of the "env_temp" field in the mutation.
func (m *HeartbeatMutation) EnvTemp() (r uint16, exists bool) {
	v := m.env_temp
	if v == nil {
		return
	}
	return *v, true
}

// OldEnvTemp returns the old "env_temp" field's value of the Heartbeat entity.
// If the Heartbeat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HeartbeatMutation) OldEnvTemp(ctx context.Context) (v uint16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnvTemp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnvTemp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnvTemp: %w", err)
	}
	return oldValue.EnvTemp, nil
}

// AddEnvTemp adds u to the "env_temp" field.
func (m *HeartbeatMutation) AddEnvTemp(u int16) {
	if m.addenv_temp != nil {
		*m.addenv_temp += u
	} else {
		m.addenv_temp = &u
	}
}

// AddedEnvTemp returns the value that was added to the "env_temp" field in this mutation.
func (m *HeartbeatMutation) AddedEnvTemp() (r int16, exists bool) {
	v := m.addenv_temp
	if v == nil {
		return
	}
	return *v, true
}

// ResetEnvTemp resets all changes to the "env_temp" field.
func (m *HeartbeatMutation) ResetEnvTemp() {
	m.env_temp = nil
	m.addenv_temp = nil
}

// SetGeom sets the "geom" field.
func (m *HeartbeatMutation) SetGeom(a *adapter.Geometry) {
	m.geom = &a
}

// Geom returns the value of the "geom" field in the mutation.
func (m *HeartbeatMutation) Geom() (r *adapter.Geometry, exists bool) {
	v := m.geom
	if v == nil {
		return
	}
	return *v, true
}

// OldGeom returns the old "geom" field's value of the Heartbeat entity.
// If the Heartbeat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HeartbeatMutation) OldGeom(ctx context.Context) (v *adapter.Geometry, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGeom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGeom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeom: %w", err)
	}
	return oldValue.Geom, nil
}

// ResetGeom resets all changes to the "geom" field.
func (m *HeartbeatMutation) ResetGeom() {
	m.geom = nil
}

// SetGps sets the "gps" field.
func (m *HeartbeatMutation) SetGps(xs xcdef.GPSStatus) {
	m.gps = &xs
}

// Gps returns the value of the "gps" field in the mutation.
func (m *HeartbeatMutation) Gps() (r xcdef.GPSStatus, exists bool) {
	v := m.gps
	if v == nil {
		return
	}
	return *v, true
}

// OldGps returns the old "gps" field's value of the Heartbeat entity.
// If the Heartbeat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HeartbeatMutation) OldGps(ctx context.Context) (v xcdef.GPSStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGps is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGps requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGps: %w", err)
	}
	return oldValue.Gps, nil
}

// ResetGps resets all changes to the "gps" field.
func (m *HeartbeatMutation) ResetGps() {
	m.gps = nil
}

// SetStrength sets the "strength" field.
func (m *HeartbeatMutation) SetStrength(u uint8) {
	m.strength = &u
	m.addstrength = nil
}

// Strength returns the value of the "strength" field in the mutation.
func (m *HeartbeatMutation) Strength() (r uint8, exists bool) {
	v := m.strength
	if v == nil {
		return
	}
	return *v, true
}

// OldStrength returns the old "strength" field's value of the Heartbeat entity.
// If the Heartbeat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HeartbeatMutation) OldStrength(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStrength is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStrength requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStrength: %w", err)
	}
	return oldValue.Strength, nil
}

// AddStrength adds u to the "strength" field.
func (m *HeartbeatMutation) AddStrength(u int8) {
	if m.addstrength != nil {
		*m.addstrength += u
	} else {
		m.addstrength = &u
	}
}

// AddedStrength returns the value that was added to the "strength" field in this mutation.
func (m *HeartbeatMutation) AddedStrength() (r int8, exists bool) {
	v := m.addstrength
	if v == nil {
		return
	}
	return *v, true
}

// ResetStrength resets all changes to the "strength" field.
func (m *HeartbeatMutation) ResetStrength() {
	m.strength = nil
	m.addstrength = nil
}

// SetCycles sets the "cycles" field.
func (m *HeartbeatMutation) SetCycles(u uint16) {
	m.cycles = &u
	m.addcycles = nil
}

// Cycles returns the value of the "cycles" field in the mutation.
func (m *HeartbeatMutation) Cycles() (r uint16, exists bool) {
	v := m.cycles
	if v == nil {
		return
	}
	return *v, true
}

// OldCycles returns the old "cycles" field's value of the Heartbeat entity.
// If the Heartbeat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HeartbeatMutation) OldCycles(ctx context.Context) (v uint16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCycles is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCycles requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCycles: %w", err)
	}
	return oldValue.Cycles, nil
}

// AddCycles adds u to the "cycles" field.
func (m *HeartbeatMutation) AddCycles(u int16) {
	if m.addcycles != nil {
		*m.addcycles += u
	} else {
		m.addcycles = &u
	}
}

// AddedCycles returns the value that was added to the "cycles" field in this mutation.
func (m *HeartbeatMutation) AddedCycles() (r int16, exists bool) {
	v := m.addcycles
	if v == nil {
		return
	}
	return *v, true
}

// ResetCycles resets all changes to the "cycles" field.
func (m *HeartbeatMutation) ResetCycles() {
	m.cycles = nil
	m.addcycles = nil
}

// SetChargingTime sets the "charging_time" field.
func (m *HeartbeatMutation) SetChargingTime(u uint32) {
	m.charging_time = &u
	m.addcharging_time = nil
}

// ChargingTime returns the value of the "charging_time" field in the mutation.
func (m *HeartbeatMutation) ChargingTime() (r uint32, exists bool) {
	v := m.charging_time
	if v == nil {
		return
	}
	return *v, true
}

// OldChargingTime returns the old "charging_time" field's value of the Heartbeat entity.
// If the Heartbeat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HeartbeatMutation) OldChargingTime(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChargingTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChargingTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChargingTime: %w", err)
	}
	return oldValue.ChargingTime, nil
}

// AddChargingTime adds u to the "charging_time" field.
func (m *HeartbeatMutation) AddChargingTime(u int32) {
	if m.addcharging_time != nil {
		*m.addcharging_time += u
	} else {
		m.addcharging_time = &u
	}
}

// AddedChargingTime returns the value that was added to the "charging_time" field in this mutation.
func (m *HeartbeatMutation) AddedChargingTime() (r int32, exists bool) {
	v := m.addcharging_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetChargingTime resets all changes to the "charging_time" field.
func (m *HeartbeatMutation) ResetChargingTime() {
	m.charging_time = nil
	m.addcharging_time = nil
}

// SetDisChargingTime sets the "dis_charging_time" field.
func (m *HeartbeatMutation) SetDisChargingTime(u uint32) {
	m.dis_charging_time = &u
	m.adddis_charging_time = nil
}

// DisChargingTime returns the value of the "dis_charging_time" field in the mutation.
func (m *HeartbeatMutation) DisChargingTime() (r uint32, exists bool) {
	v := m.dis_charging_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDisChargingTime returns the old "dis_charging_time" field's value of the Heartbeat entity.
// If the Heartbeat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HeartbeatMutation) OldDisChargingTime(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisChargingTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisChargingTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisChargingTime: %w", err)
	}
	return oldValue.DisChargingTime, nil
}

// AddDisChargingTime adds u to the "dis_charging_time" field.
func (m *HeartbeatMutation) AddDisChargingTime(u int32) {
	if m.adddis_charging_time != nil {
		*m.adddis_charging_time += u
	} else {
		m.adddis_charging_time = &u
	}
}

// AddedDisChargingTime returns the value that was added to the "dis_charging_time" field in this mutation.
func (m *HeartbeatMutation) AddedDisChargingTime() (r int32, exists bool) {
	v := m.adddis_charging_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetDisChargingTime resets all changes to the "dis_charging_time" field.
func (m *HeartbeatMutation) ResetDisChargingTime() {
	m.dis_charging_time = nil
	m.adddis_charging_time = nil
}

// SetUsingTime sets the "using_time" field.
func (m *HeartbeatMutation) SetUsingTime(u uint32) {
	m.using_time = &u
	m.addusing_time = nil
}

// UsingTime returns the value of the "using_time" field in the mutation.
func (m *HeartbeatMutation) UsingTime() (r uint32, exists bool) {
	v := m.using_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUsingTime returns the old "using_time" field's value of the Heartbeat entity.
// If the Heartbeat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HeartbeatMutation) OldUsingTime(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsingTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsingTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsingTime: %w", err)
	}
	return oldValue.UsingTime, nil
}

// AddUsingTime adds u to the "using_time" field.
func (m *HeartbeatMutation) AddUsingTime(u int32) {
	if m.addusing_time != nil {
		*m.addusing_time += u
	} else {
		m.addusing_time = &u
	}
}

// AddedUsingTime returns the value that was added to the "using_time" field in this mutation.
func (m *HeartbeatMutation) AddedUsingTime() (r int32, exists bool) {
	v := m.addusing_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetUsingTime resets all changes to the "using_time" field.
func (m *HeartbeatMutation) ResetUsingTime() {
	m.using_time = nil
	m.addusing_time = nil
}

// SetTotalChargingTime sets the "total_charging_time" field.
func (m *HeartbeatMutation) SetTotalChargingTime(u uint32) {
	m.total_charging_time = &u
	m.addtotal_charging_time = nil
}

// TotalChargingTime returns the value of the "total_charging_time" field in the mutation.
func (m *HeartbeatMutation) TotalChargingTime() (r uint32, exists bool) {
	v := m.total_charging_time
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalChargingTime returns the old "total_charging_time" field's value of the Heartbeat entity.
// If the Heartbeat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HeartbeatMutation) OldTotalChargingTime(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalChargingTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalChargingTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalChargingTime: %w", err)
	}
	return oldValue.TotalChargingTime, nil
}

// AddTotalChargingTime adds u to the "total_charging_time" field.
func (m *HeartbeatMutation) AddTotalChargingTime(u int32) {
	if m.addtotal_charging_time != nil {
		*m.addtotal_charging_time += u
	} else {
		m.addtotal_charging_time = &u
	}
}

// AddedTotalChargingTime returns the value that was added to the "total_charging_time" field in this mutation.
func (m *HeartbeatMutation) AddedTotalChargingTime() (r int32, exists bool) {
	v := m.addtotal_charging_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalChargingTime resets all changes to the "total_charging_time" field.
func (m *HeartbeatMutation) ResetTotalChargingTime() {
	m.total_charging_time = nil
	m.addtotal_charging_time = nil
}

// SetTotalDisChargingTime sets the "total_dis_charging_time" field.
func (m *HeartbeatMutation) SetTotalDisChargingTime(u uint32) {
	m.total_dis_charging_time = &u
	m.addtotal_dis_charging_time = nil
}

// TotalDisChargingTime returns the value of the "total_dis_charging_time" field in the mutation.
func (m *HeartbeatMutation) TotalDisChargingTime() (r uint32, exists bool) {
	v := m.total_dis_charging_time
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalDisChargingTime returns the old "total_dis_charging_time" field's value of the Heartbeat entity.
// If the Heartbeat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HeartbeatMutation) OldTotalDisChargingTime(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalDisChargingTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalDisChargingTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalDisChargingTime: %w", err)
	}
	return oldValue.TotalDisChargingTime, nil
}

// AddTotalDisChargingTime adds u to the "total_dis_charging_time" field.
func (m *HeartbeatMutation) AddTotalDisChargingTime(u int32) {
	if m.addtotal_dis_charging_time != nil {
		*m.addtotal_dis_charging_time += u
	} else {
		m.addtotal_dis_charging_time = &u
	}
}

// AddedTotalDisChargingTime returns the value that was added to the "total_dis_charging_time" field in this mutation.
func (m *HeartbeatMutation) AddedTotalDisChargingTime() (r int32, exists bool) {
	v := m.addtotal_dis_charging_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalDisChargingTime resets all changes to the "total_dis_charging_time" field.
func (m *HeartbeatMutation) ResetTotalDisChargingTime() {
	m.total_dis_charging_time = nil
	m.addtotal_dis_charging_time = nil
}

// SetTotalUsingTime sets the "total_using_time" field.
func (m *HeartbeatMutation) SetTotalUsingTime(u uint32) {
	m.total_using_time = &u
	m.addtotal_using_time = nil
}

// TotalUsingTime returns the value of the "total_using_time" field in the mutation.
func (m *HeartbeatMutation) TotalUsingTime() (r uint32, exists bool) {
	v := m.total_using_time
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalUsingTime returns the old "total_using_time" field's value of the Heartbeat entity.
// If the Heartbeat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HeartbeatMutation) OldTotalUsingTime(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalUsingTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalUsingTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalUsingTime: %w", err)
	}
	return oldValue.TotalUsingTime, nil
}

// AddTotalUsingTime adds u to the "total_using_time" field.
func (m *HeartbeatMutation) AddTotalUsingTime(u int32) {
	if m.addtotal_using_time != nil {
		*m.addtotal_using_time += u
	} else {
		m.addtotal_using_time = &u
	}
}

// AddedTotalUsingTime returns the value that was added to the "total_using_time" field in this mutation.
func (m *HeartbeatMutation) AddedTotalUsingTime() (r int32, exists bool) {
	v := m.addtotal_using_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalUsingTime resets all changes to the "total_using_time" field.
func (m *HeartbeatMutation) ResetTotalUsingTime() {
	m.total_using_time = nil
	m.addtotal_using_time = nil
}

// ClearBattery clears the "battery" edge to the Battery entity.
func (m *HeartbeatMutation) ClearBattery() {
	m.clearedbattery = true
}

// BatteryCleared reports if the "battery" edge to the Battery entity was cleared.
func (m *HeartbeatMutation) BatteryCleared() bool {
	return m.clearedbattery
}

// BatteryIDs returns the "battery" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BatteryID instead. It exists only for internal usage by the builders.
func (m *HeartbeatMutation) BatteryIDs() (ids []int) {
	if id := m.battery; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBattery resets all changes to the "battery" edge.
func (m *HeartbeatMutation) ResetBattery() {
	m.battery = nil
	m.clearedbattery = false
}

// Where appends a list predicates to the HeartbeatMutation builder.
func (m *HeartbeatMutation) Where(ps ...predicate.Heartbeat) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HeartbeatMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HeartbeatMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Heartbeat, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HeartbeatMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HeartbeatMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Heartbeat).
func (m *HeartbeatMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HeartbeatMutation) Fields() []string {
	fields := make([]string, 0, 31)
	if m.sn != nil {
		fields = append(fields, heartbeat.FieldSn)
	}
	if m.battery != nil {
		fields = append(fields, heartbeat.FieldBatteryID)
	}
	if m.created_at != nil {
		fields = append(fields, heartbeat.FieldCreatedAt)
	}
	if m.voltage != nil {
		fields = append(fields, heartbeat.FieldVoltage)
	}
	if m.current != nil {
		fields = append(fields, heartbeat.FieldCurrent)
	}
	if m.soc != nil {
		fields = append(fields, heartbeat.FieldSoc)
	}
	if m.soh != nil {
		fields = append(fields, heartbeat.FieldSoh)
	}
	if m.in_cabinet != nil {
		fields = append(fields, heartbeat.FieldInCabinet)
	}
	if m.capacity != nil {
		fields = append(fields, heartbeat.FieldCapacity)
	}
	if m.mon_max_voltage != nil {
		fields = append(fields, heartbeat.FieldMonMaxVoltage)
	}
	if m.mon_max_voltage_pos != nil {
		fields = append(fields, heartbeat.FieldMonMaxVoltagePos)
	}
	if m.mon_min_voltage != nil {
		fields = append(fields, heartbeat.FieldMonMinVoltage)
	}
	if m.mon_min_voltage_pos != nil {
		fields = append(fields, heartbeat.FieldMonMinVoltagePos)
	}
	if m.max_temp != nil {
		fields = append(fields, heartbeat.FieldMaxTemp)
	}
	if m.min_temp != nil {
		fields = append(fields, heartbeat.FieldMinTemp)
	}
	if m.faults != nil {
		fields = append(fields, heartbeat.FieldFaults)
	}
	if m.mos_status != nil {
		fields = append(fields, heartbeat.FieldMosStatus)
	}
	if m.mon_voltage != nil {
		fields = append(fields, heartbeat.FieldMonVoltage)
	}
	if m.temp != nil {
		fields = append(fields, heartbeat.FieldTemp)
	}
	if m.mos_temp != nil {
		fields = append(fields, heartbeat.FieldMosTemp)
	}
	if m.env_temp != nil {
		fields = append(fields, heartbeat.FieldEnvTemp)
	}
	if m.geom != nil {
		fields = append(fields, heartbeat.FieldGeom)
	}
	if m.gps != nil {
		fields = append(fields, heartbeat.FieldGps)
	}
	if m.strength != nil {
		fields = append(fields, heartbeat.FieldStrength)
	}
	if m.cycles != nil {
		fields = append(fields, heartbeat.FieldCycles)
	}
	if m.charging_time != nil {
		fields = append(fields, heartbeat.FieldChargingTime)
	}
	if m.dis_charging_time != nil {
		fields = append(fields, heartbeat.FieldDisChargingTime)
	}
	if m.using_time != nil {
		fields = append(fields, heartbeat.FieldUsingTime)
	}
	if m.total_charging_time != nil {
		fields = append(fields, heartbeat.FieldTotalChargingTime)
	}
	if m.total_dis_charging_time != nil {
		fields = append(fields, heartbeat.FieldTotalDisChargingTime)
	}
	if m.total_using_time != nil {
		fields = append(fields, heartbeat.FieldTotalUsingTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HeartbeatMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case heartbeat.FieldSn:
		return m.Sn()
	case heartbeat.FieldBatteryID:
		return m.BatteryID()
	case heartbeat.FieldCreatedAt:
		return m.CreatedAt()
	case heartbeat.FieldVoltage:
		return m.Voltage()
	case heartbeat.FieldCurrent:
		return m.Current()
	case heartbeat.FieldSoc:
		return m.Soc()
	case heartbeat.FieldSoh:
		return m.Soh()
	case heartbeat.FieldInCabinet:
		return m.InCabinet()
	case heartbeat.FieldCapacity:
		return m.Capacity()
	case heartbeat.FieldMonMaxVoltage:
		return m.MonMaxVoltage()
	case heartbeat.FieldMonMaxVoltagePos:
		return m.MonMaxVoltagePos()
	case heartbeat.FieldMonMinVoltage:
		return m.MonMinVoltage()
	case heartbeat.FieldMonMinVoltagePos:
		return m.MonMinVoltagePos()
	case heartbeat.FieldMaxTemp:
		return m.MaxTemp()
	case heartbeat.FieldMinTemp:
		return m.MinTemp()
	case heartbeat.FieldFaults:
		return m.Faults()
	case heartbeat.FieldMosStatus:
		return m.MosStatus()
	case heartbeat.FieldMonVoltage:
		return m.MonVoltage()
	case heartbeat.FieldTemp:
		return m.Temp()
	case heartbeat.FieldMosTemp:
		return m.MosTemp()
	case heartbeat.FieldEnvTemp:
		return m.EnvTemp()
	case heartbeat.FieldGeom:
		return m.Geom()
	case heartbeat.FieldGps:
		return m.Gps()
	case heartbeat.FieldStrength:
		return m.Strength()
	case heartbeat.FieldCycles:
		return m.Cycles()
	case heartbeat.FieldChargingTime:
		return m.ChargingTime()
	case heartbeat.FieldDisChargingTime:
		return m.DisChargingTime()
	case heartbeat.FieldUsingTime:
		return m.UsingTime()
	case heartbeat.FieldTotalChargingTime:
		return m.TotalChargingTime()
	case heartbeat.FieldTotalDisChargingTime:
		return m.TotalDisChargingTime()
	case heartbeat.FieldTotalUsingTime:
		return m.TotalUsingTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HeartbeatMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case heartbeat.FieldSn:
		return m.OldSn(ctx)
	case heartbeat.FieldBatteryID:
		return m.OldBatteryID(ctx)
	case heartbeat.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case heartbeat.FieldVoltage:
		return m.OldVoltage(ctx)
	case heartbeat.FieldCurrent:
		return m.OldCurrent(ctx)
	case heartbeat.FieldSoc:
		return m.OldSoc(ctx)
	case heartbeat.FieldSoh:
		return m.OldSoh(ctx)
	case heartbeat.FieldInCabinet:
		return m.OldInCabinet(ctx)
	case heartbeat.FieldCapacity:
		return m.OldCapacity(ctx)
	case heartbeat.FieldMonMaxVoltage:
		return m.OldMonMaxVoltage(ctx)
	case heartbeat.FieldMonMaxVoltagePos:
		return m.OldMonMaxVoltagePos(ctx)
	case heartbeat.FieldMonMinVoltage:
		return m.OldMonMinVoltage(ctx)
	case heartbeat.FieldMonMinVoltagePos:
		return m.OldMonMinVoltagePos(ctx)
	case heartbeat.FieldMaxTemp:
		return m.OldMaxTemp(ctx)
	case heartbeat.FieldMinTemp:
		return m.OldMinTemp(ctx)
	case heartbeat.FieldFaults:
		return m.OldFaults(ctx)
	case heartbeat.FieldMosStatus:
		return m.OldMosStatus(ctx)
	case heartbeat.FieldMonVoltage:
		return m.OldMonVoltage(ctx)
	case heartbeat.FieldTemp:
		return m.OldTemp(ctx)
	case heartbeat.FieldMosTemp:
		return m.OldMosTemp(ctx)
	case heartbeat.FieldEnvTemp:
		return m.OldEnvTemp(ctx)
	case heartbeat.FieldGeom:
		return m.OldGeom(ctx)
	case heartbeat.FieldGps:
		return m.OldGps(ctx)
	case heartbeat.FieldStrength:
		return m.OldStrength(ctx)
	case heartbeat.FieldCycles:
		return m.OldCycles(ctx)
	case heartbeat.FieldChargingTime:
		return m.OldChargingTime(ctx)
	case heartbeat.FieldDisChargingTime:
		return m.OldDisChargingTime(ctx)
	case heartbeat.FieldUsingTime:
		return m.OldUsingTime(ctx)
	case heartbeat.FieldTotalChargingTime:
		return m.OldTotalChargingTime(ctx)
	case heartbeat.FieldTotalDisChargingTime:
		return m.OldTotalDisChargingTime(ctx)
	case heartbeat.FieldTotalUsingTime:
		return m.OldTotalUsingTime(ctx)
	}
	return nil, fmt.Errorf("unknown Heartbeat field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HeartbeatMutation) SetField(name string, value ent.Value) error {
	switch name {
	case heartbeat.FieldSn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSn(v)
		return nil
	case heartbeat.FieldBatteryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBatteryID(v)
		return nil
	case heartbeat.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case heartbeat.FieldVoltage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVoltage(v)
		return nil
	case heartbeat.FieldCurrent:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrent(v)
		return nil
	case heartbeat.FieldSoc:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSoc(v)
		return nil
	case heartbeat.FieldSoh:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSoh(v)
		return nil
	case heartbeat.FieldInCabinet:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInCabinet(v)
		return nil
	case heartbeat.FieldCapacity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCapacity(v)
		return nil
	case heartbeat.FieldMonMaxVoltage:
		v, ok := value.(uint16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMonMaxVoltage(v)
		return nil
	case heartbeat.FieldMonMaxVoltagePos:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMonMaxVoltagePos(v)
		return nil
	case heartbeat.FieldMonMinVoltage:
		v, ok := value.(uint16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMonMinVoltage(v)
		return nil
	case heartbeat.FieldMonMinVoltagePos:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMonMinVoltagePos(v)
		return nil
	case heartbeat.FieldMaxTemp:
		v, ok := value.(uint16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxTemp(v)
		return nil
	case heartbeat.FieldMinTemp:
		v, ok := value.(uint16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinTemp(v)
		return nil
	case heartbeat.FieldFaults:
		v, ok := value.(*xcdef.Faults)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFaults(v)
		return nil
	case heartbeat.FieldMosStatus:
		v, ok := value.(*xcdef.MosStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMosStatus(v)
		return nil
	case heartbeat.FieldMonVoltage:
		v, ok := value.(*xcdef.MonVoltage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMonVoltage(v)
		return nil
	case heartbeat.FieldTemp:
		v, ok := value.(*xcdef.Temperature)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemp(v)
		return nil
	case heartbeat.FieldMosTemp:
		v, ok := value.(uint16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMosTemp(v)
		return nil
	case heartbeat.FieldEnvTemp:
		v, ok := value.(uint16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnvTemp(v)
		return nil
	case heartbeat.FieldGeom:
		v, ok := value.(*adapter.Geometry)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeom(v)
		return nil
	case heartbeat.FieldGps:
		v, ok := value.(xcdef.GPSStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGps(v)
		return nil
	case heartbeat.FieldStrength:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStrength(v)
		return nil
	case heartbeat.FieldCycles:
		v, ok := value.(uint16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCycles(v)
		return nil
	case heartbeat.FieldChargingTime:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChargingTime(v)
		return nil
	case heartbeat.FieldDisChargingTime:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisChargingTime(v)
		return nil
	case heartbeat.FieldUsingTime:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsingTime(v)
		return nil
	case heartbeat.FieldTotalChargingTime:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalChargingTime(v)
		return nil
	case heartbeat.FieldTotalDisChargingTime:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalDisChargingTime(v)
		return nil
	case heartbeat.FieldTotalUsingTime:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalUsingTime(v)
		return nil
	}
	return fmt.Errorf("unknown Heartbeat field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HeartbeatMutation) AddedFields() []string {
	var fields []string
	if m.addvoltage != nil {
		fields = append(fields, heartbeat.FieldVoltage)
	}
	if m.addcurrent != nil {
		fields = append(fields, heartbeat.FieldCurrent)
	}
	if m.addsoc != nil {
		fields = append(fields, heartbeat.FieldSoc)
	}
	if m.addsoh != nil {
		fields = append(fields, heartbeat.FieldSoh)
	}
	if m.addcapacity != nil {
		fields = append(fields, heartbeat.FieldCapacity)
	}
	if m.addmon_max_voltage != nil {
		fields = append(fields, heartbeat.FieldMonMaxVoltage)
	}
	if m.addmon_max_voltage_pos != nil {
		fields = append(fields, heartbeat.FieldMonMaxVoltagePos)
	}
	if m.addmon_min_voltage != nil {
		fields = append(fields, heartbeat.FieldMonMinVoltage)
	}
	if m.addmon_min_voltage_pos != nil {
		fields = append(fields, heartbeat.FieldMonMinVoltagePos)
	}
	if m.addmax_temp != nil {
		fields = append(fields, heartbeat.FieldMaxTemp)
	}
	if m.addmin_temp != nil {
		fields = append(fields, heartbeat.FieldMinTemp)
	}
	if m.addmos_temp != nil {
		fields = append(fields, heartbeat.FieldMosTemp)
	}
	if m.addenv_temp != nil {
		fields = append(fields, heartbeat.FieldEnvTemp)
	}
	if m.addstrength != nil {
		fields = append(fields, heartbeat.FieldStrength)
	}
	if m.addcycles != nil {
		fields = append(fields, heartbeat.FieldCycles)
	}
	if m.addcharging_time != nil {
		fields = append(fields, heartbeat.FieldChargingTime)
	}
	if m.adddis_charging_time != nil {
		fields = append(fields, heartbeat.FieldDisChargingTime)
	}
	if m.addusing_time != nil {
		fields = append(fields, heartbeat.FieldUsingTime)
	}
	if m.addtotal_charging_time != nil {
		fields = append(fields, heartbeat.FieldTotalChargingTime)
	}
	if m.addtotal_dis_charging_time != nil {
		fields = append(fields, heartbeat.FieldTotalDisChargingTime)
	}
	if m.addtotal_using_time != nil {
		fields = append(fields, heartbeat.FieldTotalUsingTime)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HeartbeatMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case heartbeat.FieldVoltage:
		return m.AddedVoltage()
	case heartbeat.FieldCurrent:
		return m.AddedCurrent()
	case heartbeat.FieldSoc:
		return m.AddedSoc()
	case heartbeat.FieldSoh:
		return m.AddedSoh()
	case heartbeat.FieldCapacity:
		return m.AddedCapacity()
	case heartbeat.FieldMonMaxVoltage:
		return m.AddedMonMaxVoltage()
	case heartbeat.FieldMonMaxVoltagePos:
		return m.AddedMonMaxVoltagePos()
	case heartbeat.FieldMonMinVoltage:
		return m.AddedMonMinVoltage()
	case heartbeat.FieldMonMinVoltagePos:
		return m.AddedMonMinVoltagePos()
	case heartbeat.FieldMaxTemp:
		return m.AddedMaxTemp()
	case heartbeat.FieldMinTemp:
		return m.AddedMinTemp()
	case heartbeat.FieldMosTemp:
		return m.AddedMosTemp()
	case heartbeat.FieldEnvTemp:
		return m.AddedEnvTemp()
	case heartbeat.FieldStrength:
		return m.AddedStrength()
	case heartbeat.FieldCycles:
		return m.AddedCycles()
	case heartbeat.FieldChargingTime:
		return m.AddedChargingTime()
	case heartbeat.FieldDisChargingTime:
		return m.AddedDisChargingTime()
	case heartbeat.FieldUsingTime:
		return m.AddedUsingTime()
	case heartbeat.FieldTotalChargingTime:
		return m.AddedTotalChargingTime()
	case heartbeat.FieldTotalDisChargingTime:
		return m.AddedTotalDisChargingTime()
	case heartbeat.FieldTotalUsingTime:
		return m.AddedTotalUsingTime()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HeartbeatMutation) AddField(name string, value ent.Value) error {
	switch name {
	case heartbeat.FieldVoltage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVoltage(v)
		return nil
	case heartbeat.FieldCurrent:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCurrent(v)
		return nil
	case heartbeat.FieldSoc:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSoc(v)
		return nil
	case heartbeat.FieldSoh:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSoh(v)
		return nil
	case heartbeat.FieldCapacity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCapacity(v)
		return nil
	case heartbeat.FieldMonMaxVoltage:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMonMaxVoltage(v)
		return nil
	case heartbeat.FieldMonMaxVoltagePos:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMonMaxVoltagePos(v)
		return nil
	case heartbeat.FieldMonMinVoltage:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMonMinVoltage(v)
		return nil
	case heartbeat.FieldMonMinVoltagePos:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMonMinVoltagePos(v)
		return nil
	case heartbeat.FieldMaxTemp:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxTemp(v)
		return nil
	case heartbeat.FieldMinTemp:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinTemp(v)
		return nil
	case heartbeat.FieldMosTemp:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMosTemp(v)
		return nil
	case heartbeat.FieldEnvTemp:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEnvTemp(v)
		return nil
	case heartbeat.FieldStrength:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStrength(v)
		return nil
	case heartbeat.FieldCycles:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCycles(v)
		return nil
	case heartbeat.FieldChargingTime:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChargingTime(v)
		return nil
	case heartbeat.FieldDisChargingTime:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDisChargingTime(v)
		return nil
	case heartbeat.FieldUsingTime:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUsingTime(v)
		return nil
	case heartbeat.FieldTotalChargingTime:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalChargingTime(v)
		return nil
	case heartbeat.FieldTotalDisChargingTime:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalDisChargingTime(v)
		return nil
	case heartbeat.FieldTotalUsingTime:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalUsingTime(v)
		return nil
	}
	return fmt.Errorf("unknown Heartbeat numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HeartbeatMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(heartbeat.FieldFaults) {
		fields = append(fields, heartbeat.FieldFaults)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HeartbeatMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HeartbeatMutation) ClearField(name string) error {
	switch name {
	case heartbeat.FieldFaults:
		m.ClearFaults()
		return nil
	}
	return fmt.Errorf("unknown Heartbeat nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HeartbeatMutation) ResetField(name string) error {
	switch name {
	case heartbeat.FieldSn:
		m.ResetSn()
		return nil
	case heartbeat.FieldBatteryID:
		m.ResetBatteryID()
		return nil
	case heartbeat.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case heartbeat.FieldVoltage:
		m.ResetVoltage()
		return nil
	case heartbeat.FieldCurrent:
		m.ResetCurrent()
		return nil
	case heartbeat.FieldSoc:
		m.ResetSoc()
		return nil
	case heartbeat.FieldSoh:
		m.ResetSoh()
		return nil
	case heartbeat.FieldInCabinet:
		m.ResetInCabinet()
		return nil
	case heartbeat.FieldCapacity:
		m.ResetCapacity()
		return nil
	case heartbeat.FieldMonMaxVoltage:
		m.ResetMonMaxVoltage()
		return nil
	case heartbeat.FieldMonMaxVoltagePos:
		m.ResetMonMaxVoltagePos()
		return nil
	case heartbeat.FieldMonMinVoltage:
		m.ResetMonMinVoltage()
		return nil
	case heartbeat.FieldMonMinVoltagePos:
		m.ResetMonMinVoltagePos()
		return nil
	case heartbeat.FieldMaxTemp:
		m.ResetMaxTemp()
		return nil
	case heartbeat.FieldMinTemp:
		m.ResetMinTemp()
		return nil
	case heartbeat.FieldFaults:
		m.ResetFaults()
		return nil
	case heartbeat.FieldMosStatus:
		m.ResetMosStatus()
		return nil
	case heartbeat.FieldMonVoltage:
		m.ResetMonVoltage()
		return nil
	case heartbeat.FieldTemp:
		m.ResetTemp()
		return nil
	case heartbeat.FieldMosTemp:
		m.ResetMosTemp()
		return nil
	case heartbeat.FieldEnvTemp:
		m.ResetEnvTemp()
		return nil
	case heartbeat.FieldGeom:
		m.ResetGeom()
		return nil
	case heartbeat.FieldGps:
		m.ResetGps()
		return nil
	case heartbeat.FieldStrength:
		m.ResetStrength()
		return nil
	case heartbeat.FieldCycles:
		m.ResetCycles()
		return nil
	case heartbeat.FieldChargingTime:
		m.ResetChargingTime()
		return nil
	case heartbeat.FieldDisChargingTime:
		m.ResetDisChargingTime()
		return nil
	case heartbeat.FieldUsingTime:
		m.ResetUsingTime()
		return nil
	case heartbeat.FieldTotalChargingTime:
		m.ResetTotalChargingTime()
		return nil
	case heartbeat.FieldTotalDisChargingTime:
		m.ResetTotalDisChargingTime()
		return nil
	case heartbeat.FieldTotalUsingTime:
		m.ResetTotalUsingTime()
		return nil
	}
	return fmt.Errorf("unknown Heartbeat field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HeartbeatMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.battery != nil {
		edges = append(edges, heartbeat.EdgeBattery)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HeartbeatMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case heartbeat.EdgeBattery:
		if id := m.battery; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HeartbeatMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HeartbeatMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HeartbeatMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbattery {
		edges = append(edges, heartbeat.EdgeBattery)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HeartbeatMutation) EdgeCleared(name string) bool {
	switch name {
	case heartbeat.EdgeBattery:
		return m.clearedbattery
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HeartbeatMutation) ClearEdge(name string) error {
	switch name {
	case heartbeat.EdgeBattery:
		m.ClearBattery()
		return nil
	}
	return fmt.Errorf("unknown Heartbeat unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HeartbeatMutation) ResetEdge(name string) error {
	switch name {
	case heartbeat.EdgeBattery:
		m.ResetBattery()
		return nil
	}
	return fmt.Errorf("unknown Heartbeat edge %s", name)
}

// ReignMutation represents an operation that mutates the Reign nodes in the graph.
type ReignMutation struct {
	config
	op             Op
	typ            string
	id             *int
	action         *batdef.ReignAction
	sn             *string
	created_at     *time.Time
	serial         *string
	ordinal        *int
	addordinal     *int
	cabinet_name   *string
	remark         *string
	geom           **adapter.Geometry
	clearedFields  map[string]struct{}
	battery        *int
	clearedbattery bool
	done           bool
	oldValue       func(context.Context) (*Reign, error)
	predicates     []predicate.Reign
}

var _ ent.Mutation = (*ReignMutation)(nil)

// reignOption allows management of the mutation configuration using functional options.
type reignOption func(*ReignMutation)

// newReignMutation creates new mutation for the Reign entity.
func newReignMutation(c config, op Op, opts ...reignOption) *ReignMutation {
	m := &ReignMutation{
		config:        c,
		op:            op,
		typ:           TypeReign,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReignID sets the ID field of the mutation.
func withReignID(id int) reignOption {
	return func(m *ReignMutation) {
		var (
			err   error
			once  sync.Once
			value *Reign
		)
		m.oldValue = func(ctx context.Context) (*Reign, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Reign.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReign sets the old Reign of the mutation.
func withReign(node *Reign) reignOption {
	return func(m *ReignMutation) {
		m.oldValue = func(context.Context) (*Reign, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReignMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReignMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReignMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReignMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Reign.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAction sets the "action" field.
func (m *ReignMutation) SetAction(ba batdef.ReignAction) {
	m.action = &ba
}

// Action returns the value of the "action" field in the mutation.
func (m *ReignMutation) Action() (r batdef.ReignAction, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the Reign entity.
// If the Reign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReignMutation) OldAction(ctx context.Context) (v batdef.ReignAction, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ResetAction resets all changes to the "action" field.
func (m *ReignMutation) ResetAction() {
	m.action = nil
}

// SetSn sets the "sn" field.
func (m *ReignMutation) SetSn(s string) {
	m.sn = &s
}

// Sn returns the value of the "sn" field in the mutation.
func (m *ReignMutation) Sn() (r string, exists bool) {
	v := m.sn
	if v == nil {
		return
	}
	return *v, true
}

// OldSn returns the old "sn" field's value of the Reign entity.
// If the Reign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReignMutation) OldSn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSn: %w", err)
	}
	return oldValue.Sn, nil
}

// ResetSn resets all changes to the "sn" field.
func (m *ReignMutation) ResetSn() {
	m.sn = nil
}

// SetBatteryID sets the "battery_id" field.
func (m *ReignMutation) SetBatteryID(i int) {
	m.battery = &i
}

// BatteryID returns the value of the "battery_id" field in the mutation.
func (m *ReignMutation) BatteryID() (r int, exists bool) {
	v := m.battery
	if v == nil {
		return
	}
	return *v, true
}

// OldBatteryID returns the old "battery_id" field's value of the Reign entity.
// If the Reign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReignMutation) OldBatteryID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBatteryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBatteryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBatteryID: %w", err)
	}
	return oldValue.BatteryID, nil
}

// ResetBatteryID resets all changes to the "battery_id" field.
func (m *ReignMutation) ResetBatteryID() {
	m.battery = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ReignMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ReignMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Reign entity.
// If the Reign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReignMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ReignMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetSerial sets the "serial" field.
func (m *ReignMutation) SetSerial(s string) {
	m.serial = &s
}

// Serial returns the value of the "serial" field in the mutation.
func (m *ReignMutation) Serial() (r string, exists bool) {
	v := m.serial
	if v == nil {
		return
	}
	return *v, true
}

// OldSerial returns the old "serial" field's value of the Reign entity.
// If the Reign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReignMutation) OldSerial(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerial is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerial requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerial: %w", err)
	}
	return oldValue.Serial, nil
}

// ResetSerial resets all changes to the "serial" field.
func (m *ReignMutation) ResetSerial() {
	m.serial = nil
}

// SetOrdinal sets the "ordinal" field.
func (m *ReignMutation) SetOrdinal(i int) {
	m.ordinal = &i
	m.addordinal = nil
}

// Ordinal returns the value of the "ordinal" field in the mutation.
func (m *ReignMutation) Ordinal() (r int, exists bool) {
	v := m.ordinal
	if v == nil {
		return
	}
	return *v, true
}

// OldOrdinal returns the old "ordinal" field's value of the Reign entity.
// If the Reign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReignMutation) OldOrdinal(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrdinal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrdinal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrdinal: %w", err)
	}
	return oldValue.Ordinal, nil
}

// AddOrdinal adds i to the "ordinal" field.
func (m *ReignMutation) AddOrdinal(i int) {
	if m.addordinal != nil {
		*m.addordinal += i
	} else {
		m.addordinal = &i
	}
}

// AddedOrdinal returns the value that was added to the "ordinal" field in this mutation.
func (m *ReignMutation) AddedOrdinal() (r int, exists bool) {
	v := m.addordinal
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrdinal resets all changes to the "ordinal" field.
func (m *ReignMutation) ResetOrdinal() {
	m.ordinal = nil
	m.addordinal = nil
}

// SetCabinetName sets the "cabinet_name" field.
func (m *ReignMutation) SetCabinetName(s string) {
	m.cabinet_name = &s
}

// CabinetName returns the value of the "cabinet_name" field in the mutation.
func (m *ReignMutation) CabinetName() (r string, exists bool) {
	v := m.cabinet_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCabinetName returns the old "cabinet_name" field's value of the Reign entity.
// If the Reign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReignMutation) OldCabinetName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCabinetName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCabinetName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCabinetName: %w", err)
	}
	return oldValue.CabinetName, nil
}

// ClearCabinetName clears the value of the "cabinet_name" field.
func (m *ReignMutation) ClearCabinetName() {
	m.cabinet_name = nil
	m.clearedFields[reign.FieldCabinetName] = struct{}{}
}

// CabinetNameCleared returns if the "cabinet_name" field was cleared in this mutation.
func (m *ReignMutation) CabinetNameCleared() bool {
	_, ok := m.clearedFields[reign.FieldCabinetName]
	return ok
}

// ResetCabinetName resets all changes to the "cabinet_name" field.
func (m *ReignMutation) ResetCabinetName() {
	m.cabinet_name = nil
	delete(m.clearedFields, reign.FieldCabinetName)
}

// SetRemark sets the "remark" field.
func (m *ReignMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *ReignMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Reign entity.
// If the Reign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReignMutation) OldRemark(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *ReignMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[reign.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *ReignMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[reign.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *ReignMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, reign.FieldRemark)
}

// SetGeom sets the "geom" field.
func (m *ReignMutation) SetGeom(a *adapter.Geometry) {
	m.geom = &a
}

// Geom returns the value of the "geom" field in the mutation.
func (m *ReignMutation) Geom() (r *adapter.Geometry, exists bool) {
	v := m.geom
	if v == nil {
		return
	}
	return *v, true
}

// OldGeom returns the old "geom" field's value of the Reign entity.
// If the Reign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReignMutation) OldGeom(ctx context.Context) (v *adapter.Geometry, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGeom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGeom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeom: %w", err)
	}
	return oldValue.Geom, nil
}

// ResetGeom resets all changes to the "geom" field.
func (m *ReignMutation) ResetGeom() {
	m.geom = nil
}

// ClearBattery clears the "battery" edge to the Battery entity.
func (m *ReignMutation) ClearBattery() {
	m.clearedbattery = true
}

// BatteryCleared reports if the "battery" edge to the Battery entity was cleared.
func (m *ReignMutation) BatteryCleared() bool {
	return m.clearedbattery
}

// BatteryIDs returns the "battery" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BatteryID instead. It exists only for internal usage by the builders.
func (m *ReignMutation) BatteryIDs() (ids []int) {
	if id := m.battery; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBattery resets all changes to the "battery" edge.
func (m *ReignMutation) ResetBattery() {
	m.battery = nil
	m.clearedbattery = false
}

// Where appends a list predicates to the ReignMutation builder.
func (m *ReignMutation) Where(ps ...predicate.Reign) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReignMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReignMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Reign, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReignMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReignMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Reign).
func (m *ReignMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReignMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.action != nil {
		fields = append(fields, reign.FieldAction)
	}
	if m.sn != nil {
		fields = append(fields, reign.FieldSn)
	}
	if m.battery != nil {
		fields = append(fields, reign.FieldBatteryID)
	}
	if m.created_at != nil {
		fields = append(fields, reign.FieldCreatedAt)
	}
	if m.serial != nil {
		fields = append(fields, reign.FieldSerial)
	}
	if m.ordinal != nil {
		fields = append(fields, reign.FieldOrdinal)
	}
	if m.cabinet_name != nil {
		fields = append(fields, reign.FieldCabinetName)
	}
	if m.remark != nil {
		fields = append(fields, reign.FieldRemark)
	}
	if m.geom != nil {
		fields = append(fields, reign.FieldGeom)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReignMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case reign.FieldAction:
		return m.Action()
	case reign.FieldSn:
		return m.Sn()
	case reign.FieldBatteryID:
		return m.BatteryID()
	case reign.FieldCreatedAt:
		return m.CreatedAt()
	case reign.FieldSerial:
		return m.Serial()
	case reign.FieldOrdinal:
		return m.Ordinal()
	case reign.FieldCabinetName:
		return m.CabinetName()
	case reign.FieldRemark:
		return m.Remark()
	case reign.FieldGeom:
		return m.Geom()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReignMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case reign.FieldAction:
		return m.OldAction(ctx)
	case reign.FieldSn:
		return m.OldSn(ctx)
	case reign.FieldBatteryID:
		return m.OldBatteryID(ctx)
	case reign.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case reign.FieldSerial:
		return m.OldSerial(ctx)
	case reign.FieldOrdinal:
		return m.OldOrdinal(ctx)
	case reign.FieldCabinetName:
		return m.OldCabinetName(ctx)
	case reign.FieldRemark:
		return m.OldRemark(ctx)
	case reign.FieldGeom:
		return m.OldGeom(ctx)
	}
	return nil, fmt.Errorf("unknown Reign field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReignMutation) SetField(name string, value ent.Value) error {
	switch name {
	case reign.FieldAction:
		v, ok := value.(batdef.ReignAction)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case reign.FieldSn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSn(v)
		return nil
	case reign.FieldBatteryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBatteryID(v)
		return nil
	case reign.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case reign.FieldSerial:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerial(v)
		return nil
	case reign.FieldOrdinal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrdinal(v)
		return nil
	case reign.FieldCabinetName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCabinetName(v)
		return nil
	case reign.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case reign.FieldGeom:
		v, ok := value.(*adapter.Geometry)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeom(v)
		return nil
	}
	return fmt.Errorf("unknown Reign field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReignMutation) AddedFields() []string {
	var fields []string
	if m.addordinal != nil {
		fields = append(fields, reign.FieldOrdinal)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReignMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case reign.FieldOrdinal:
		return m.AddedOrdinal()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReignMutation) AddField(name string, value ent.Value) error {
	switch name {
	case reign.FieldOrdinal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrdinal(v)
		return nil
	}
	return fmt.Errorf("unknown Reign numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReignMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(reign.FieldCabinetName) {
		fields = append(fields, reign.FieldCabinetName)
	}
	if m.FieldCleared(reign.FieldRemark) {
		fields = append(fields, reign.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReignMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReignMutation) ClearField(name string) error {
	switch name {
	case reign.FieldCabinetName:
		m.ClearCabinetName()
		return nil
	case reign.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown Reign nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReignMutation) ResetField(name string) error {
	switch name {
	case reign.FieldAction:
		m.ResetAction()
		return nil
	case reign.FieldSn:
		m.ResetSn()
		return nil
	case reign.FieldBatteryID:
		m.ResetBatteryID()
		return nil
	case reign.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case reign.FieldSerial:
		m.ResetSerial()
		return nil
	case reign.FieldOrdinal:
		m.ResetOrdinal()
		return nil
	case reign.FieldCabinetName:
		m.ResetCabinetName()
		return nil
	case reign.FieldRemark:
		m.ResetRemark()
		return nil
	case reign.FieldGeom:
		m.ResetGeom()
		return nil
	}
	return fmt.Errorf("unknown Reign field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReignMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.battery != nil {
		edges = append(edges, reign.EdgeBattery)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReignMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case reign.EdgeBattery:
		if id := m.battery; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReignMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReignMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReignMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbattery {
		edges = append(edges, reign.EdgeBattery)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReignMutation) EdgeCleared(name string) bool {
	switch name {
	case reign.EdgeBattery:
		return m.clearedbattery
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReignMutation) ClearEdge(name string) error {
	switch name {
	case reign.EdgeBattery:
		m.ClearBattery()
		return nil
	}
	return fmt.Errorf("unknown Reign unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReignMutation) ResetEdge(name string) error {
	switch name {
	case reign.EdgeBattery:
		m.ResetBattery()
		return nil
	}
	return fmt.Errorf("unknown Reign edge %s", name)
}
