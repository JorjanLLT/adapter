// Code generated by ent, DO NOT EDIT.

package ent

import (
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"entgo.io/ent/dialect/sql"
	"github.com/auroraride/adapter"
	"github.com/auroraride/adapter/defs/xcdef"
	"github.com/auroraride/adapter/defs/xcdef/ent/battery"
	"github.com/auroraride/adapter/defs/xcdef/ent/heartbeat"
)

// Heartbeat is the model entity for the Heartbeat schema.
type Heartbeat struct {
	config `json:"-"`
	// ID of the ent.
	ID int `json:"id,omitempty"`
	// 电池编号
	Sn string `json:"sn,omitempty"`
	// 电池ID
	BatteryID int `json:"battery_id,omitempty"`
	// CreatedAt holds the value of the "created_at" field.
	CreatedAt time.Time `json:"created_at,omitempty"`
	// 电池总压 (V)
	Voltage float64 `json:"voltage,omitempty"`
	// 电流 (A, 充电为正, 放电为负)
	Current float64 `json:"current,omitempty"`
	// 单位1%
	Soc uint8 `json:"soc,omitempty"`
	// 单位1%
	Soh uint8 `json:"soh,omitempty"`
	// 是否在电柜
	InCabinet bool `json:"in_cabinet,omitempty"`
	// 剩余容量 (单位AH)
	Capacity float64 `json:"capacity,omitempty"`
	// 最大单体电压 (mV)
	MonMaxVoltage uint16 `json:"mon_max_voltage,omitempty"`
	// 最大单体电压位置 (第x串)
	MonMaxVoltagePos uint8 `json:"mon_max_voltage_pos,omitempty"`
	// 最小单体电压 (mV)
	MonMinVoltage uint16 `json:"mon_min_voltage,omitempty"`
	// 最小单体电压位置 (第x串)
	MonMinVoltagePos uint8 `json:"mon_min_voltage_pos,omitempty"`
	// 最大温度 (单位1℃)
	MaxTemp uint16 `json:"max_temp,omitempty"`
	// 最小温度 (单位1℃)
	MinTemp uint16 `json:"min_temp,omitempty"`
	// 故障列表
	Faults *xcdef.Faults `json:"faults,omitempty"`
	// MOS状态 (Bit0表示充电, Bit1表示放电, 此字段无法判定电池是否充放电状态)
	MosStatus *xcdef.MosStatus `json:"mos_status,omitempty"`
	// 单体电压 (24个单体电压, 单位mV)
	MonVoltage *xcdef.MonVoltage `json:"mon_voltage,omitempty"`
	// 电池温度 (4个电池温度传感器, 单位1℃)
	Temp *xcdef.Temperature `json:"temp,omitempty"`
	// MOS温度 (1个MOS温度传感器, 单位1℃)
	MosTemp uint16 `json:"mos_temp,omitempty"`
	// 环境温度 (1个环境温度传感器, 单位1℃)
	EnvTemp uint16 `json:"env_temp,omitempty"`
	// 坐标
	Geom *adapter.Geometry `json:"geom,omitempty"`
	// GPS定位状态 (0=未定位 1=GPS定位 4=LBS定位)
	Gps xcdef.GPSStatus `json:"gps,omitempty"`
	// 4G通讯信号强度 (0-100 百分比形式)
	Strength uint8 `json:"strength,omitempty"`
	// 电池包循环次数 (80%累加一次)
	Cycles uint16 `json:"cycles,omitempty"`
	// 本次充电时长
	ChargingTime uint32 `json:"charging_time,omitempty"`
	// 本次放电时长
	DisChargingTime uint32 `json:"dis_charging_time,omitempty"`
	// 本次使用时长
	UsingTime uint32 `json:"using_time,omitempty"`
	// 总充电时长
	TotalChargingTime uint32 `json:"total_charging_time,omitempty"`
	// 总放电时长
	TotalDisChargingTime uint32 `json:"total_dis_charging_time,omitempty"`
	// 总使用时长
	TotalUsingTime uint32 `json:"total_using_time,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the HeartbeatQuery when eager-loading is set.
	Edges HeartbeatEdges `json:"edges"`
}

// HeartbeatEdges holds the relations/edges for other nodes in the graph.
type HeartbeatEdges struct {
	// 所属电池
	Battery *Battery `json:"battery,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [1]bool
}

// BatteryOrErr returns the Battery value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e HeartbeatEdges) BatteryOrErr() (*Battery, error) {
	if e.loadedTypes[0] {
		if e.Battery == nil {
			// Edge was loaded but was not found.
			return nil, &NotFoundError{label: battery.Label}
		}
		return e.Battery, nil
	}
	return nil, &NotLoadedError{edge: "battery"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Heartbeat) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case heartbeat.FieldFaults, heartbeat.FieldMosStatus, heartbeat.FieldMonVoltage, heartbeat.FieldTemp:
			values[i] = new([]byte)
		case heartbeat.FieldGeom:
			values[i] = new(adapter.Geometry)
		case heartbeat.FieldInCabinet:
			values[i] = new(sql.NullBool)
		case heartbeat.FieldVoltage, heartbeat.FieldCurrent, heartbeat.FieldCapacity:
			values[i] = new(sql.NullFloat64)
		case heartbeat.FieldID, heartbeat.FieldBatteryID, heartbeat.FieldSoc, heartbeat.FieldSoh, heartbeat.FieldMonMaxVoltage, heartbeat.FieldMonMaxVoltagePos, heartbeat.FieldMonMinVoltage, heartbeat.FieldMonMinVoltagePos, heartbeat.FieldMaxTemp, heartbeat.FieldMinTemp, heartbeat.FieldMosTemp, heartbeat.FieldEnvTemp, heartbeat.FieldStrength, heartbeat.FieldCycles, heartbeat.FieldChargingTime, heartbeat.FieldDisChargingTime, heartbeat.FieldUsingTime, heartbeat.FieldTotalChargingTime, heartbeat.FieldTotalDisChargingTime, heartbeat.FieldTotalUsingTime:
			values[i] = new(sql.NullInt64)
		case heartbeat.FieldSn:
			values[i] = new(sql.NullString)
		case heartbeat.FieldCreatedAt:
			values[i] = new(sql.NullTime)
		case heartbeat.FieldGps:
			values[i] = new(xcdef.GPSStatus)
		default:
			return nil, fmt.Errorf("unexpected column %q for type Heartbeat", columns[i])
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Heartbeat fields.
func (h *Heartbeat) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case heartbeat.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			h.ID = int(value.Int64)
		case heartbeat.FieldSn:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field sn", values[i])
			} else if value.Valid {
				h.Sn = value.String
			}
		case heartbeat.FieldBatteryID:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field battery_id", values[i])
			} else if value.Valid {
				h.BatteryID = int(value.Int64)
			}
		case heartbeat.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				h.CreatedAt = value.Time
			}
		case heartbeat.FieldVoltage:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field voltage", values[i])
			} else if value.Valid {
				h.Voltage = value.Float64
			}
		case heartbeat.FieldCurrent:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field current", values[i])
			} else if value.Valid {
				h.Current = value.Float64
			}
		case heartbeat.FieldSoc:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field soc", values[i])
			} else if value.Valid {
				h.Soc = uint8(value.Int64)
			}
		case heartbeat.FieldSoh:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field soh", values[i])
			} else if value.Valid {
				h.Soh = uint8(value.Int64)
			}
		case heartbeat.FieldInCabinet:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field in_cabinet", values[i])
			} else if value.Valid {
				h.InCabinet = value.Bool
			}
		case heartbeat.FieldCapacity:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field capacity", values[i])
			} else if value.Valid {
				h.Capacity = value.Float64
			}
		case heartbeat.FieldMonMaxVoltage:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field mon_max_voltage", values[i])
			} else if value.Valid {
				h.MonMaxVoltage = uint16(value.Int64)
			}
		case heartbeat.FieldMonMaxVoltagePos:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field mon_max_voltage_pos", values[i])
			} else if value.Valid {
				h.MonMaxVoltagePos = uint8(value.Int64)
			}
		case heartbeat.FieldMonMinVoltage:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field mon_min_voltage", values[i])
			} else if value.Valid {
				h.MonMinVoltage = uint16(value.Int64)
			}
		case heartbeat.FieldMonMinVoltagePos:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field mon_min_voltage_pos", values[i])
			} else if value.Valid {
				h.MonMinVoltagePos = uint8(value.Int64)
			}
		case heartbeat.FieldMaxTemp:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field max_temp", values[i])
			} else if value.Valid {
				h.MaxTemp = uint16(value.Int64)
			}
		case heartbeat.FieldMinTemp:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field min_temp", values[i])
			} else if value.Valid {
				h.MinTemp = uint16(value.Int64)
			}
		case heartbeat.FieldFaults:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field faults", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &h.Faults); err != nil {
					return fmt.Errorf("unmarshal field faults: %w", err)
				}
			}
		case heartbeat.FieldMosStatus:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field mos_status", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &h.MosStatus); err != nil {
					return fmt.Errorf("unmarshal field mos_status: %w", err)
				}
			}
		case heartbeat.FieldMonVoltage:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field mon_voltage", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &h.MonVoltage); err != nil {
					return fmt.Errorf("unmarshal field mon_voltage: %w", err)
				}
			}
		case heartbeat.FieldTemp:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field temp", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &h.Temp); err != nil {
					return fmt.Errorf("unmarshal field temp: %w", err)
				}
			}
		case heartbeat.FieldMosTemp:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field mos_temp", values[i])
			} else if value.Valid {
				h.MosTemp = uint16(value.Int64)
			}
		case heartbeat.FieldEnvTemp:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field env_temp", values[i])
			} else if value.Valid {
				h.EnvTemp = uint16(value.Int64)
			}
		case heartbeat.FieldGeom:
			if value, ok := values[i].(*adapter.Geometry); !ok {
				return fmt.Errorf("unexpected type %T for field geom", values[i])
			} else if value != nil {
				h.Geom = value
			}
		case heartbeat.FieldGps:
			if value, ok := values[i].(*xcdef.GPSStatus); !ok {
				return fmt.Errorf("unexpected type %T for field gps", values[i])
			} else if value != nil {
				h.Gps = *value
			}
		case heartbeat.FieldStrength:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field strength", values[i])
			} else if value.Valid {
				h.Strength = uint8(value.Int64)
			}
		case heartbeat.FieldCycles:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field cycles", values[i])
			} else if value.Valid {
				h.Cycles = uint16(value.Int64)
			}
		case heartbeat.FieldChargingTime:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field charging_time", values[i])
			} else if value.Valid {
				h.ChargingTime = uint32(value.Int64)
			}
		case heartbeat.FieldDisChargingTime:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field dis_charging_time", values[i])
			} else if value.Valid {
				h.DisChargingTime = uint32(value.Int64)
			}
		case heartbeat.FieldUsingTime:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field using_time", values[i])
			} else if value.Valid {
				h.UsingTime = uint32(value.Int64)
			}
		case heartbeat.FieldTotalChargingTime:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field total_charging_time", values[i])
			} else if value.Valid {
				h.TotalChargingTime = uint32(value.Int64)
			}
		case heartbeat.FieldTotalDisChargingTime:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field total_dis_charging_time", values[i])
			} else if value.Valid {
				h.TotalDisChargingTime = uint32(value.Int64)
			}
		case heartbeat.FieldTotalUsingTime:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field total_using_time", values[i])
			} else if value.Valid {
				h.TotalUsingTime = uint32(value.Int64)
			}
		}
	}
	return nil
}

// QueryBattery queries the "battery" edge of the Heartbeat entity.
func (h *Heartbeat) QueryBattery() *BatteryQuery {
	return NewHeartbeatClient(h.config).QueryBattery(h)
}

// Update returns a builder for updating this Heartbeat.
// Note that you need to call Heartbeat.Unwrap() before calling this method if this Heartbeat
// was returned from a transaction, and the transaction was committed or rolled back.
func (h *Heartbeat) Update() *HeartbeatUpdateOne {
	return NewHeartbeatClient(h.config).UpdateOne(h)
}

// Unwrap unwraps the Heartbeat entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (h *Heartbeat) Unwrap() *Heartbeat {
	_tx, ok := h.config.driver.(*txDriver)
	if !ok {
		panic("ent: Heartbeat is not a transactional entity")
	}
	h.config.driver = _tx.drv
	return h
}

// String implements the fmt.Stringer.
func (h *Heartbeat) String() string {
	var builder strings.Builder
	builder.WriteString("Heartbeat(")
	builder.WriteString(fmt.Sprintf("id=%v, ", h.ID))
	builder.WriteString("sn=")
	builder.WriteString(h.Sn)
	builder.WriteString(", ")
	builder.WriteString("battery_id=")
	builder.WriteString(fmt.Sprintf("%v", h.BatteryID))
	builder.WriteString(", ")
	builder.WriteString("created_at=")
	builder.WriteString(h.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("voltage=")
	builder.WriteString(fmt.Sprintf("%v", h.Voltage))
	builder.WriteString(", ")
	builder.WriteString("current=")
	builder.WriteString(fmt.Sprintf("%v", h.Current))
	builder.WriteString(", ")
	builder.WriteString("soc=")
	builder.WriteString(fmt.Sprintf("%v", h.Soc))
	builder.WriteString(", ")
	builder.WriteString("soh=")
	builder.WriteString(fmt.Sprintf("%v", h.Soh))
	builder.WriteString(", ")
	builder.WriteString("in_cabinet=")
	builder.WriteString(fmt.Sprintf("%v", h.InCabinet))
	builder.WriteString(", ")
	builder.WriteString("capacity=")
	builder.WriteString(fmt.Sprintf("%v", h.Capacity))
	builder.WriteString(", ")
	builder.WriteString("mon_max_voltage=")
	builder.WriteString(fmt.Sprintf("%v", h.MonMaxVoltage))
	builder.WriteString(", ")
	builder.WriteString("mon_max_voltage_pos=")
	builder.WriteString(fmt.Sprintf("%v", h.MonMaxVoltagePos))
	builder.WriteString(", ")
	builder.WriteString("mon_min_voltage=")
	builder.WriteString(fmt.Sprintf("%v", h.MonMinVoltage))
	builder.WriteString(", ")
	builder.WriteString("mon_min_voltage_pos=")
	builder.WriteString(fmt.Sprintf("%v", h.MonMinVoltagePos))
	builder.WriteString(", ")
	builder.WriteString("max_temp=")
	builder.WriteString(fmt.Sprintf("%v", h.MaxTemp))
	builder.WriteString(", ")
	builder.WriteString("min_temp=")
	builder.WriteString(fmt.Sprintf("%v", h.MinTemp))
	builder.WriteString(", ")
	builder.WriteString("faults=")
	builder.WriteString(fmt.Sprintf("%v", h.Faults))
	builder.WriteString(", ")
	builder.WriteString("mos_status=")
	builder.WriteString(fmt.Sprintf("%v", h.MosStatus))
	builder.WriteString(", ")
	builder.WriteString("mon_voltage=")
	builder.WriteString(fmt.Sprintf("%v", h.MonVoltage))
	builder.WriteString(", ")
	builder.WriteString("temp=")
	builder.WriteString(fmt.Sprintf("%v", h.Temp))
	builder.WriteString(", ")
	builder.WriteString("mos_temp=")
	builder.WriteString(fmt.Sprintf("%v", h.MosTemp))
	builder.WriteString(", ")
	builder.WriteString("env_temp=")
	builder.WriteString(fmt.Sprintf("%v", h.EnvTemp))
	builder.WriteString(", ")
	builder.WriteString("geom=")
	builder.WriteString(fmt.Sprintf("%v", h.Geom))
	builder.WriteString(", ")
	builder.WriteString("gps=")
	builder.WriteString(fmt.Sprintf("%v", h.Gps))
	builder.WriteString(", ")
	builder.WriteString("strength=")
	builder.WriteString(fmt.Sprintf("%v", h.Strength))
	builder.WriteString(", ")
	builder.WriteString("cycles=")
	builder.WriteString(fmt.Sprintf("%v", h.Cycles))
	builder.WriteString(", ")
	builder.WriteString("charging_time=")
	builder.WriteString(fmt.Sprintf("%v", h.ChargingTime))
	builder.WriteString(", ")
	builder.WriteString("dis_charging_time=")
	builder.WriteString(fmt.Sprintf("%v", h.DisChargingTime))
	builder.WriteString(", ")
	builder.WriteString("using_time=")
	builder.WriteString(fmt.Sprintf("%v", h.UsingTime))
	builder.WriteString(", ")
	builder.WriteString("total_charging_time=")
	builder.WriteString(fmt.Sprintf("%v", h.TotalChargingTime))
	builder.WriteString(", ")
	builder.WriteString("total_dis_charging_time=")
	builder.WriteString(fmt.Sprintf("%v", h.TotalDisChargingTime))
	builder.WriteString(", ")
	builder.WriteString("total_using_time=")
	builder.WriteString(fmt.Sprintf("%v", h.TotalUsingTime))
	builder.WriteByte(')')
	return builder.String()
}

// Heartbeats is a parsable slice of Heartbeat.
type Heartbeats []*Heartbeat

func (h Heartbeats) config(cfg config) {
	for _i := range h {
		h[_i].config = cfg
	}
}
